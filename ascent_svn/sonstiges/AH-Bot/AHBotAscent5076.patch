Index: sql/AHBotItems.sql
===================================================================
--- sql/AHBotItems.sql	(Revision 0)
+++ sql/AHBotItems.sql	(Revision 0)
@@ -0,0 +1,108 @@
+/* This is a Character Database table */
+
+DROP TABLE IF EXISTS `ahbotitems`;
+
+CREATE TABLE `ahbotitems` (
+  `auctionhouse` int(10)    NOT NULL,
+  `itemid`       bigint(30) NOT NULL,
+  `itemcount`    int(10)    NOT NULL,
+  PRIMARY KEY  (`auctionhouse`,`itemid`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+CREATE INDEX `ahbotitems0`
+  USING BTREE 
+  ON `ahbotitems` (`auctionhouse`,`itemid`);
+
+/* Uncomment this section if you want these default items */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21843,  5); /* Imbued Netherweave Bag */
+
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21843,  5); /* Imbued Netherweave Bag */
+
+/* SELECT * FROM `ahbotitems` */
+/* This is a Character Database table */
+
+DROP TABLE IF EXISTS `ahbotitems`;
+
+CREATE TABLE `ahbotitems` (
+  `auctionhouse` int(10)    NOT NULL,
+  `itemid`       bigint(30) NOT NULL,
+  `itemcount`    int(10)    NOT NULL,
+  PRIMARY KEY  (`auctionhouse`,`itemid`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+CREATE INDEX `ahbotitems0`
+  USING BTREE 
+  ON `ahbotitems` (`auctionhouse`,`itemid`);
+
+/* Uncomment this section if you want these default items */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21843,  5); /* Imbued Netherweave Bag */
+
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21843,  5); /* Imbued Netherweave Bag */
+
+/* SELECT * FROM `ahbotitems` */
+/* This is a Character Database table */
+
+DROP TABLE IF EXISTS `ahbotitems`;
+
+CREATE TABLE `ahbotitems` (
+  `auctionhouse` int(10)    NOT NULL,
+  `itemid`       bigint(30) NOT NULL,
+  `itemcount`    int(10)    NOT NULL,
+  PRIMARY KEY  (`auctionhouse`,`itemid`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+CREATE INDEX `ahbotitems0`
+  USING BTREE 
+  ON `ahbotitems` (`auctionhouse`,`itemid`);
+
+/* Uncomment this section if you want these default items */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21843,  5); /* Imbued Netherweave Bag */
+
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21843,  5); /* Imbued Netherweave Bag */
+
+/* SELECT * FROM `ahbotitems` */
+/* This is a Character Database table */
+
+DROP TABLE IF EXISTS `ahbotitems`;
+
+CREATE TABLE `ahbotitems` (
+  `auctionhouse` int(10)    NOT NULL,
+  `itemid`       bigint(30) NOT NULL,
+  `itemcount`    int(10)    NOT NULL,
+  PRIMARY KEY  (`auctionhouse`,`itemid`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+CREATE INDEX `ahbotitems0`
+  USING BTREE 
+  ON `ahbotitems` (`auctionhouse`,`itemid`);
+
+/* Uncomment this section if you want these default items */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (1, 21843,  5); /* Imbued Netherweave Bag */
+
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2,  4500, 20); /* Travelers Backpack */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 14156,  1); /* Bottomless Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21841, 10); /* Netherweave Bag */
+/*INSERT INTO `ahbotitems` (`auctionhouse`, `itemid`, `itemcount`) VALUES (2, 21843,  5); /* Imbued Netherweave Bag */
+
+/* SELECT * FROM `ahbotitems` */
Index: src/AHBot.conf
===================================================================
--- src/AHBot.conf	(Revision 0)
+++ src/AHBot.conf	(Revision 0)
@@ -0,0 +1,143 @@
+#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
+# Auctions Setup
+#
+# WorldAnnounce:
+# If 1, then announce to the players in the world that the auction house is loading
+# Default: 0
+#
+# LoadOnStartUp:
+# If 1, then load the auction house(s) at startup
+# Default: 0
+#
+# CleanMailboxes
+# If CleanMailboxes = 1, looks for AH-related mail for the AHBot character
+# and deletes it.
+# Default: 0
+#
+# ClearOnStartUp:
+# If 1, then clear ALL the auction house(s) of all auctions
+# The purpose of this is to keep the playeritems table from growing extremely large
+# with items that were left behind when the auction was removed/expired/cancelled.
+# Default: 0
+#
+# RefreshInterval
+# If LoadOnStartup = 1, the number of hours between refreshing
+# (this option will be phased out)
+# Default: 1
+#
+# RefreshMinutes
+# If LoadOnStartup = 1, the number of minutes between refreshing
+# Default: 60
+#
+# ExpirationMinutes:
+# Minutes before the auction expires
+# Default: 1440 (1 day)
+#
+# RandomizeExpiration:
+# If RandomizeExpiration = 1, then will it randomize auction length between
+# ExpirationMinutes/8 and ExpirationMinutes
+# Default: 0
+#
+# PlayerName:
+# The player to use when creating auctions, default guid is 0 if player is not found
+# Default: AHbot
+#
+# MinAuctions:
+# If LoadOnStartup = 1, the minimum number of items to have in the auction house
+# Default: None
+#
+# MinItemLevel:
+# Minimum Level of the item
+# Default: 0
+#
+# MaxItemLevel:
+# Maximum Level of the item
+# Default: Maximum integer value in C++
+#
+# MaxItemCount:
+# Maximum number of a specific item id for auction
+# Default: 0 (disabled)
+#
+# MinPlayerLevel:
+# Minimum Level of the player to use the item
+# Default: 0
+#
+# MaxPlayerLevel:
+# Maximum Level of the player to use the item
+# Default: Maximum integer value in C++
+#
+# MinQuality:
+# Minimum Quality of the items
+# 1 = Poor, 2 = Common, 3 = Rare, 4 = Epic, 5 = Legendary
+# Default: 0
+#
+# MaxQuality:
+# Maximum Quality of the items
+# 1 = Poor, 2 = Common, 3 = Rare, 4 = Epic, 5 = Legendary
+# Default: Maximum integer value in C++
+# MaxStack:
+# Maximum number of items in a stacked item
+# 0 = Only 1 item, 1 = Random between 1 and maximum, 2 = Maximum possible for an item
+# Default: 2
+#
+# Houses:
+# Specifies the auction houses to load
+# 1 = Alliance, 2 = Horde, 3 = Neutral
+# Default: None
+#
+# BidMultiplier:
+# Multiplication factor applied to the item's buy price
+# Default: 0
+#
+# BuyoutMultiplier:
+# Multiplication factor applied to the item's buy price
+# Default: 1
+#
+# AllowQuestItems:
+# 0 = Exclude items with a quest id, 1 = Allow items with a quest id
+# Default: 0
+#
+# IncludeClasses:
+# List of classes to include
+# Default: 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
+#
+# 0 = ITEM_CLASS_CONSUMABLE 8 = ITEM_CLASS_GENERIC
+# 1 = ITEM_CLASS_CONTAINER 9 = ITEM_CLASS_RECIPE
+# 2 = ITEM_CLASS_WEAPON 10 = ITEM_CLASS_MONEY
+# 3 = ITEM_CLASS_JEWELRY 11 = ITEM_CLASS_QUIVER
+# 4 = ITEM_CLASS_ARMOR 12 = ITEM_CLASS_QUEST
+# 5 = ITEM_CLASS_REAGENT 13 = ITEM_CLASS_KEY
+# 6 = ITEM_CLASS_PROJECTILE 14 = ITEM_CLASS_PERMANENT
+# 7 = ITEM_CLASS_TRADEGOODS 15 = ITEM_CLASS_MISCELLANEOUS
+#
+# LogLevel:
+# If 1, then display more informational events, 2 then more, etc.
+# Default: 0
+#
+#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
+
+<Auctions LoadOnStartUp = "1"
+ClearOnStartup = "0"
+CleanMailboxes = "0"
+RefreshMinutes = "30"
+ExpirationMinutes = "30"
+RandomizeExpiration = "2"
+PlayerName = "Engel"
+MinAuctions = "3000"
+MinItemLevel = "40"
+MaxItemLevel = "200"
+MaxItemCount = "0"
+MinPlayerLevel = "0"
+MaxPlayerLevel = "100"
+MinQuality = "1"
+MaxQuality = "10"
+MaxStack = "2"
+Houses = "1,2,7"
+BidMultiplier = "0"
+BuyoutMultiplier = "1"
+AllowQuestItems = "1"
+IncludeClasses = "1,2,3,4,5,6,7,8,9,10,11,14,15"
+WorldAnnounce = "0"
+LogLevel = "0">
+# This comment is used to make sure the XML terminator > of the <auctions> section is not the very last thing in the Ascent file,
+# since most people add it to the very end of the ascent.conf.
\ No newline at end of file
Index: src/ascent-world/AHBot.cpp
===================================================================
--- src/ascent-world/AHBot.cpp	(Revision 0)
+++ src/ascent-world/AHBot.cpp	(Revision 0)
@@ -0,0 +1,1086 @@
+/****************************************************************************
+ *
+ * Auction House System
+ * Copyright (c) 2007 Team Ascent
+ *
+ * This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0
+ * License. To view a copy of this license, visit
+ * http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative Commons,
+ * 543 Howard Street, 5th Floor, San Francisco, California, 94105, USA.
+ *
+ * EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU
+ * ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES
+ * ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ */
+
+#include "StdAfx.h"
+#include "MersenneTwister.h"
+#include "Chat.h"
+#include "../../src/ascent-world/CConsole.h"
+#include <time.h>
+
+initialiseSingleton( AHBot );
+
+inline std::string MyConvertToString(const int arg)
+{
+	stringstream out;
+	out << arg;
+	return out.str();
+}
+
+inline std::string MyConvertToString(const uint32 arg)
+{
+	stringstream out;
+	out << arg;
+	return out.str();
+}
+
+inline std::string MyConvertToString(const float arg)
+{
+	stringstream out;
+	out << arg;
+	return out.str();
+}
+
+void AHBot::OnStart()
+{
+	return;
+}
+
+void AHBot::LoadSettings()
+{
+	m_ThreadTask = AHBOT_SLEEPING;
+
+	m_LogLevel = Config.MainConfig.GetIntDefault("Auctions", "LogLevel", 0);
+	m_ClearOnStartup = Config.MainConfig.GetIntDefault("Auctions", "ClearOnStartup", 0);
+	m_RefreshInterval = Config.MainConfig.GetIntDefault("Auctions", "RefreshInterval", 1);
+	m_RefreshMinutes = Config.MainConfig.GetIntDefault("Auctions", "RefreshMinutes", 60);
+	m_LoadOnStartUp = Config.MainConfig.GetIntDefault("Auctions", "LoadOnStartUp", 0);
+	m_CleanMailboxes = Config.MainConfig.GetIntDefault("Auctions", "CleanMailboxes", 0);
+	m_MinAuctions = Config.MainConfig.GetIntDefault("Auctions", "MinAuctions", 0);
+	m_Houses = Config.MainConfig.GetStringDefault("Auctions", "Houses", "");
+	m_AnnounceLoading = Config.MainConfig.GetIntDefault("Auctions", "WorldAnnounce", 0);
+	m_ExpirationMinutes = Config.MainConfig.GetIntDefault("Auctions", "ExpirationMinutes", 1440);  // this is in minutes - (1440 = 1 day)
+	m_RandomizeExpiration = Config.MainConfig.GetIntDefault("Auctions", "RandomizeExpiration", 0);
+	m_IncludeClasses = Config.MainConfig.GetStringDefault("Auctions", "IncludeClasses", "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15");
+	m_AllowQuestItems = Config.MainConfig.GetIntDefault("Auctions", "AllowQuestItems", 0);
+	m_MinItemLevel = Config.MainConfig.GetIntDefault("Auctions", "MinItemLevel", 0);
+	m_MaxItemLevel = Config.MainConfig.GetIntDefault("Auctions", "MaxItemLevel", INT_MAX);
+	m_MinPlayerLevel = Config.MainConfig.GetIntDefault("Auctions", "MinPlayerLevel", 0);
+	m_MaxPlayerLevel = Config.MainConfig.GetIntDefault("Auctions", "MaxPlayerLevel", INT_MAX);
+	m_MinItemQuality = Config.MainConfig.GetIntDefault("Auctions", "MinQuality", 1);
+	m_MaxItemQuality = Config.MainConfig.GetIntDefault("Auctions", "MaxQuality", INT_MAX);
+	m_MaxItemCount = Config.MainConfig.GetIntDefault("Auctions", "MaxItemCount", 0);
+	m_MaxStack = Config.MainConfig.GetIntDefault("Auctions", "MaxStack", 2);
+	m_CustomPrices = Config.MainConfig.GetIntDefault("Auctions", "CustomPrices", 0);
+	m_BuyoutMultiplier = Config.MainConfig.GetFloatDefault("Auctions", "BuyoutMultiplier", 1);
+	m_BidMultiplier = Config.MainConfig.GetFloatDefault("Auctions", "BidMultiplier", 0);
+	m_PlayerName = Config.MainConfig.GetStringDefault("Auctions", "PlayerName", "Ahbot");
+
+	m_PlayerGuid = 0;
+
+	QueryResult *resultPlayer = CharacterDatabase.Query("SELECT guid FROM characters WHERE name = '%s'", m_PlayerName.c_str());
+	if(resultPlayer)
+	{
+		Field *fields = resultPlayer->Fetch();
+		m_PlayerGuid = fields[0].GetUInt32();
+
+		delete resultPlayer;
+	}
+
+	m_ThreadTask = AHBOT_STARTUP;
+
+	return;
+}
+
+void AHBot::SetThreadTask(AHBOT_THREAD_TASKS task)
+{
+	m_ThreadTask = task;
+}
+
+AHBOT_THREAD_TASKS AHBot::GetThreadTask()
+{
+	return m_ThreadTask;
+}
+
+bool AHBot::GetThreadTask(AHBOT_THREAD_TASKS task)
+{
+	return (m_ThreadTask == task);
+}
+
+
+bool ChatHandler::HandleAHBotCountCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotCountAH(NULL, m_session);
+}
+
+bool AHBot::AHBotCountAH(BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	QueryResult *result = CharacterDatabase.Query( "SELECT auctionHouse, COUNT(auctionId) FROM auctions GROUP BY auctionHouse" );
+	if(!result)
+	{
+		delete result;
+
+		QueryResult *resultHouses = WorldDatabase.Query( "SELECT DISTINCT `group` FROM auctionhouse ORDER BY `group`" );
+		if(!resultHouses)
+		{
+			snprintf(msg, 200, "ERROR: No auction houses were found in the World database AuctionHouse table.");
+			
+			if ( m_session )
+				sChatHandler.RedSystemMessage(m_session, msg);
+			else
+				{pConsole->Write(msg); pConsole->Write("\n");}
+
+			return false;
+		}
+
+		do
+		{
+			Field *fields = resultHouses->Fetch();
+			uint32 ahid = fields[0].GetUInt32();
+
+			snprintf(msg, 200, "AH - > '%u' contains '0' auctions.", ahid);
+				
+			if ( m_session )
+				sChatHandler.BlueSystemMessage(m_session, msg);
+			else
+				{pConsole->Write(msg); pConsole->Write("\n");}
+
+		}while (resultHouses->NextRow());
+
+		delete resultHouses;
+
+		return false;
+	}
+
+	do
+	{
+		Field *fields = result->Fetch();
+		uint32 ahid = fields[0].GetUInt32();
+		uint32 ahcount = fields[1].GetUInt32();
+
+		snprintf(msg, 200, "AH - > '%u' contains '%u' auctions.", ahid, ahcount);
+
+		if ( m_session )
+			sChatHandler.BlueSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+	}while (result->NextRow());
+
+	delete result;
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotRefreshCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotRefreshMinutesAH(string(args), NULL, m_session);
+}
+
+void AHBot::AHBotSendMessage(char msg, BaseConsole * pConsole, WorldSession *m_session)
+{
+	return;
+}
+
+bool AHBot::AHBotRefreshMinutesAH(string args, BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	if(args.length() == 0)
+	{ 
+		snprintf(msg, 200, "ERROR: You must specify a new refresh interval for AHBot.");
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+			{pConsole->Write(msg); pConsole->Write("\n");}
+
+		return false;
+	}
+
+	int NewRefreshMinutes = atoi(args.c_str());
+
+	if(NewRefreshMinutes < 5)
+	{
+		snprintf(msg, 200, "ERROR: The min refresh interval is 5 minutes, '%u' is too small.", NewRefreshMinutes);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+			{pConsole->Write(msg); pConsole->Write("\n");}
+
+		return false;
+	}
+
+	if(NewRefreshMinutes > 1440)
+	{
+		snprintf(msg, 200, "ERROR: The max refresh interval is 1,440 minutes, '%u' is too big.", NewRefreshMinutes);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+			{pConsole->Write(msg); pConsole->Write("\n");}
+
+		return false;
+	}
+
+	if(m_RefreshMinutes != NewRefreshMinutes)
+	{
+		sAHBotMgr.m_RefreshMinutes = NewRefreshMinutes;
+		sAHBotMgr.m_ThreadTask = AHBOT_SETTINGS;
+
+		snprintf(msg, 200, "Queued a new AHBot refresh minutes change to '%u'.", NewRefreshMinutes);
+	}
+	else
+		snprintf(msg, 200, "There was no change in the refresh minutes because the interval is already '%u'.", m_RefreshMinutes);
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotLogLevelCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotLogLevelAH(string(args), NULL, m_session);
+}
+
+bool AHBot::AHBotLogLevelAH(string args, BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	if(args.length() == 0)
+	{
+		snprintf(msg, 200, "ERROR: You must specify a new AHBot log level.");
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+			{pConsole->Write(msg); pConsole->Write("\n");}
+
+		return false;
+	}
+
+	int NewLogLevel = atoi(args.c_str());
+	if(NewLogLevel < 0)
+		NewLogLevel = 0;
+
+	if(NewLogLevel > 255)
+		NewLogLevel = 9;
+
+	if(m_LogLevel != NewLogLevel)
+	{
+		sAHBotMgr.m_LogLevel = NewLogLevel;
+		sAHBotMgr.m_ThreadTask = AHBOT_SETTINGS;
+
+		snprintf(msg, 200, "Queued a new AHBot log level change to '%u'.", NewLogLevel);
+	}
+	else
+		snprintf(msg, 200, "There was no change in the log level because the log level is already '%u'.", m_LogLevel);
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotListCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotListAH(NULL, m_session);
+}
+
+bool AHBot::AHBotListAH(BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	QueryResult *result = WorldDatabase.Query( "SELECT DISTINCT `group` FROM auctionhouse ORDER BY `group`" );
+	if(!result)
+	{
+		snprintf(msg, 200, "ERROR: No auction houses were found in the World database AuctionHouse table.");
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+		return false;
+	}
+
+	do
+	{
+		Field *fields = result->Fetch();
+		uint32 ahid = fields[0].GetUInt32();
+
+		snprintf(msg, 200, "AH - > '%u' was found.", ahid);
+
+		if ( m_session )
+			sChatHandler.BlueSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+	}while (result->NextRow());
+
+	delete result;
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotLoadCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotLoadAH(string(args), NULL, m_session);
+}
+
+bool AHBot::AHBotLoadAH(string args, BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	if(args.length() == 0)
+	{
+		snprintf(msg, 200, "You must at least specify a number of items to add to an auction house.");
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+		return false;
+	}
+
+	uint32 itemsToAdd = 0;
+	uint32 AHid = 0;
+	if(sscanf(args.c_str(), "%u %u", &itemsToAdd, &AHid) < 1)
+	{
+		snprintf(msg, 200, "You must at least specify a number of items to add to an auction house.");
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+		return true;
+	}
+
+	Player * plr = NULL;
+
+	if ( m_session )
+		plr = m_session->GetPlayer();
+
+	// Get an auctioneer for the Auction House reference
+	uint32 auctioneer = GetAnAuctioneer(plr, AHid);
+
+	if(auctioneer == 0)
+	{
+		snprintf(msg, 200, "Unable to access an auctioneer for auction house '%u'.", AHid);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+		return true;
+	}
+
+	// Create a reference to the Auction House
+	AuctionHouse * ah = sAuctionMgr.GetAuctionHouse(auctioneer);
+	if(!ah)
+	{
+		snprintf(msg, 200, "Unable to access auction house '%u' using auctioneer '%u'.", AHid, auctioneer);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+		return true;
+	}
+
+	if(sLog.m_fileLogLevel >= 1)
+	{
+		if ( m_session )
+			snprintf(msg, 200, "Player %s initiated an AH load of '%u' items for ah '%u'.", plr->GetName(), itemsToAdd, ah->GetID());
+		else
+			snprintf(msg, 200, "Player %s initiated an AH load of '%u' items for ah '%u'.", "[Console]", itemsToAdd, ah->GetID());
+
+		{pConsole->Write(msg); pConsole->Write("\n");}
+	}
+
+	sAHBotMgr.plr = plr;
+	sAHBotMgr.ah = ah;
+	sAHBotMgr.itemsToAdd = itemsToAdd;
+	sAHBotMgr.m_ThreadTask = AHBOT_LOAD;
+
+	snprintf(msg, 200, "Queued the loading of AH `%u` with `%u` items using `%u`.", ah->GetID(), itemsToAdd, auctioneer);
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotPreLoadCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotPreloadAH(string(args), NULL, m_session);
+}
+
+bool AHBot::AHBotPreloadAH(string args, BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	uint32 AHid = 0;
+	if(args.length() == 0)
+		AHid = atol(args.c_str());
+
+	// Default to AH 1
+	if(AHid == 0)
+		AHid = 1;
+
+	Player * plr = NULL;
+
+	if ( m_session )
+		Player * plr = m_session->GetPlayer();
+
+	// Get an auctioneer for the Auction House reference
+	uint32 auctioneer = GetAnAuctioneer(plr, AHid);
+
+	if(auctioneer == 0)
+	{
+		snprintf(msg, 200, "Unable to access an auctioneer for auction house '%u'.", AHid);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+		return true;
+	}
+
+	// Create a reference to the Auction House
+	AuctionHouse * ah = sAuctionMgr.GetAuctionHouse(auctioneer);
+	if(!ah)
+	{
+		snprintf(msg, 200, "Unable to access auction house '%u' using auctioneer '%u'.", AHid, auctioneer);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+		    {pConsole->Write(msg); pConsole->Write("\n");}
+
+		return true;
+	}
+
+	if(!plr)
+		plr = new Player( sAHBotMgr.m_PlayerGuid);
+
+	sAHBotMgr.plr = plr;
+	sAHBotMgr.ah = ah;
+	sAHBotMgr.m_ThreadTask = AHBOT_PRELOAD;
+	
+	snprintf(msg, 200, "Queued the pre-loading of auction house '%u'.", ah->GetID());
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+	    {pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotUnloadCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotUnLoadAH(string(args), NULL, m_session);
+}
+
+bool AHBot::AHBotUnLoadAH(string args, BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	uint32 AHid = 0;
+	if(args.length() > 0)
+		AHid = atol(args.c_str());
+
+	// Default to AH 1
+	if(AHid == 0)
+		AHid = 1;
+
+	Player * plr = NULL;
+
+	if ( m_session )
+		plr = m_session->GetPlayer();
+
+	// Get an auctioneer for the Auction House reference
+	uint32 auctioneer = GetAnAuctioneer(plr, AHid);
+
+	if(auctioneer == 0)
+	{
+		snprintf(msg, 200, "Unable to access an auctioneer for auction house '%u'.", AHid);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+			{pConsole->Write(msg); pConsole->Write("\n");}
+
+		return true;
+	}
+
+	// Create a reference to the Auction House
+	AuctionHouse * ah = sAuctionMgr.GetAuctionHouse(auctioneer);
+	if(!ah)
+	{
+		snprintf(msg, 200, "Unable to access auction house '%u' using auctioneer '%u'.", AHid, auctioneer);
+
+		if ( m_session )
+			sChatHandler.RedSystemMessage(m_session, msg);
+		else
+			{pConsole->Write(msg); pConsole->Write("\n");}
+
+		return true;
+	}
+
+	if(sLog.m_fileLogLevel >= 1)
+	{
+		if ( m_session )
+			snprintf(msg, 200, "Player %s initiated an unload for ah '%u'.", plr->GetName(), ah->GetID());
+		else
+			snprintf(msg, 200, "Player %s initiated an unload for ah '%u'.", "[Console]", ah->GetID());
+
+		{pConsole->Write(msg); pConsole->Write("\n");}
+	}
+
+	sAHBotMgr.plr = plr;
+	sAHBotMgr.ah = ah;
+	sAHBotMgr.m_ThreadTask = AHBOT_UNLOAD;
+
+	snprintf(msg, 200, "Queued the un-loading of auction house '%u'.", ah->GetID());
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotAutoCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotAutoAH(NULL, m_session);
+}
+
+bool AHBot::AHBotAutoAH(BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	Player * plr = NULL;
+
+	if ( m_session )
+		plr = m_session->GetPlayer();
+
+	sAHBotMgr.plr = plr;
+	sAHBotMgr.m_ThreadTask = AHBOT_UPDATE;
+	
+	snprintf(msg, 200, "Queued the updating of all the auction houses.");
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotReloadCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotReloadAH(NULL, m_session);
+}
+
+bool AHBot::AHBotReloadAH(BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	snprintf(msg, 200, "Queued the reloading of all the auction houses.");
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	// Refresh the auction houses
+	sAuctionMgr.LoadAuctionHouses();
+
+	return true;
+}
+bool ChatHandler::HandleAHBotClearCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotClearAH(NULL, m_session);
+}
+
+bool AHBot::AHBotClearAH(BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	Player * plr = NULL;
+
+	if ( m_session )
+		Player * plr = m_session->GetPlayer();
+
+	sAHBotMgr.plr = plr;
+	sAHBotMgr.m_ThreadTask = AHBOT_CLEAR;
+	
+	snprintf(msg, 200, "Queued the clearing of all auction houses.");
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotTimeCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotTimeAH(NULL, m_session);
+}
+
+bool AHBot::AHBotTimeAH(BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	uint32 maxAuctionTime = (uint32)(m_ExpirationMinutes * 60); // the configured maximum length of an auction
+	uint32 minAuctionTime = (uint32)(maxAuctionTime / 8); // the derived minimum length of an auction
+	uint32 minExpireTime = (uint32)UNIXTIME + minAuctionTime;
+	uint32 maxExpireTime = (uint32)UNIXTIME + maxAuctionTime;
+
+	snprintf(msg, 200, "UNIXTIME is %u, minExpireTime is %u, maxExpireTime is %u", (uint32)UNIXTIME, minExpireTime, maxExpireTime);
+
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+bool ChatHandler::HandleAHBotConfigCommand(const char* args, WorldSession *m_session)
+{
+	return sAHBotMgr.AHBotConfigAH(NULL, m_session);
+}
+
+bool AHBot::AHBotConfigAH(BaseConsole * pConsole, WorldSession *m_session)
+{
+	char msg[200];
+
+	if(pConsole)
+		pConsole->Write("\n");
+
+	snprintf(msg, 200, "AHBot configuration information:");
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tLoadOnStartUp = %u", m_LoadOnStartUp);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tClearOnStartup = %u", m_ClearOnStartup);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tCleanMailboxes = %u", m_CleanMailboxes);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tRefreshMinutes = %u", m_RefreshMinutes);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tExpirationMinutes = %u", m_ExpirationMinutes);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tRandomizeExpiration = %u", m_RandomizeExpiration);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tMinAuctions = %u", m_MinAuctions);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tHouses = %s", m_Houses.c_str());
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tWorldAnnounce = %u", m_AnnounceLoading);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tCustomPrices = %u", m_CustomPrices);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tBuyoutMultiplier = %u", m_BuyoutMultiplier);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tBidMultiplier = %u", m_BidMultiplier);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tLogLevel = %u", m_LogLevel);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tPlayerName = %s", m_PlayerName.c_str());
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	snprintf(msg, 200, "\tPlayerGuid = %u", m_PlayerGuid);
+	if ( m_session )
+		sChatHandler.BlueSystemMessage(m_session, msg);
+	else
+		{pConsole->Write(msg); pConsole->Write("\n");}
+
+	return true;
+}
+
+void AHBot::ModifyRemoveAuction(AuctionHouseDBC * dbc, Auction * auct)
+{
+	// when owner is playerGuid, it was an automatically loaded item and can be ignored in some cases
+	if (auct->Owner == sAHBotMgr.m_PlayerGuid)
+	{
+		// If we are our own highest bidder, then just expire the auction and delete the item
+		if((auct->Owner == sAHBotMgr.m_PlayerGuid) && (auct->HighestBidder == sAHBotMgr.m_PlayerGuid))
+		{
+			auct->DeletedReason = AUCTION_REMOVE_EXPIRED;
+			auct->pItem->DeleteFromDB();
+		}
+
+		if ( (sAHBotMgr.m_LogLevel >= 2) || (sLog.m_screenLogLevel > 1) )
+			sLog.outString("Auction House %u: Removing auction %u because of reason %u.", dbc->id, auct->Id, auct->DeletedReason);
+	}
+}
+
+void AHBot::AHBotConsoleCommands(BaseConsole * pConsole, int argc, string args)
+{
+	string cmd = "";
+	bool ok2ShowHelp = false;
+
+	if((args.length() > 0) && (argc > 0))
+	{
+		cmd = string(args);
+		ASCENT_TOLOWER(cmd);
+
+		if(cmd.find("help") != std::string::npos)
+			ok2ShowHelp = true;
+	}
+	else
+		ok2ShowHelp = true;
+
+	if(ok2ShowHelp == true)
+	{
+		pConsole->Write("\n");
+		pConsole->Write("ahbot console commands are:\n");
+		pConsole->Write("  auto     - triggers the automatic startup event\n");
+		pConsole->Write("  clear    - clears ALL auctions from ALL auction houses\n");
+		pConsole->Write("  config   - shows AHBot configuration information\n");
+		pConsole->Write("  count    - counts the auctions on all the auction houses\n");
+		pConsole->Write("  help     - displays this information\n");
+		pConsole->Write("  list     - lists the available auction houses\n");
+		pConsole->Write("  load     - loads an auction house <required itemsToAdd> <optional AHId>\n");
+		pConsole->Write("  reload   - Re-loads all auction houses from SQL\n");
+		pConsole->Write("  loglevel - Change the AHBot log level\n");
+		pConsole->Write("  preload  - triggers the pre-loading of the auction houses\n");
+		pConsole->Write("  unload   - unloads an auction house <required AHId>\n");
+		pConsole->Write("  refresh  - Change the refresh interval\n");
+		pConsole->Write("  time     - shows the current UNIXTIME\n");
+		pConsole->Write("");
+
+		return;
+	}
+
+	size_t pos = 0;
+
+	if(cmd.find("auto") != std::string::npos)
+	{
+		pos = cmd.find("auto");
+		cmd.replace(pos, 4, "");
+
+		sAHBotMgr.AHBotAutoAH(pConsole, NULL);
+	}
+
+	if(cmd.find("time") != std::string::npos)
+	{
+		pos = cmd.find("time");
+		cmd.replace(pos, 4, "");
+
+		sAHBotMgr.AHBotTimeAH(pConsole, NULL);
+	}
+
+	if(cmd.find("config") != std::string::npos)
+	{
+		pos = cmd.find("config");
+		cmd.replace(pos, 6, "");
+
+		sAHBotMgr.AHBotConfigAH(pConsole, NULL);
+	}
+
+	if(cmd.find("refresh") != std::string::npos)
+	{
+		pos = cmd.find("refresh");
+		cmd.replace(pos, 7, "");
+
+		sAHBotMgr.AHBotRefreshMinutesAH(cmd, pConsole, NULL);
+	}
+
+	if(cmd.find("clear") != std::string::npos)
+	{
+		pos = cmd.find("clear");
+		cmd.replace(pos, 5, "");
+
+		sAHBotMgr.AHBotClearAH(pConsole, NULL);
+	}
+
+	if(cmd.find("count") != std::string::npos)
+	{
+		pos = cmd.find("count");
+		cmd.replace(pos, 5, "");
+
+		sAHBotMgr.AHBotCountAH(pConsole, NULL);
+	}
+
+	if(cmd.find("list") != std::string::npos)
+	{
+		pos = cmd.find("list");
+		cmd.replace(pos, 4, "");
+
+		sAHBotMgr.AHBotListAH(pConsole, NULL);
+	}
+
+	if(cmd.find("loglevel") != std::string::npos)
+	{
+		pos = cmd.find("loglevel");
+		cmd.replace(pos, 8, "");
+
+		sAHBotMgr.AHBotLogLevelAH(cmd, pConsole, NULL);
+	}
+
+	if(cmd.find("preload") != std::string::npos)
+	{
+		pos = cmd.find("preload");
+		cmd.replace(pos, 7, "");
+
+		sAHBotMgr.AHBotPreloadAH(cmd, pConsole, NULL);
+	}
+
+	if(cmd.find("reload") != std::string::npos)
+	{
+		pos = cmd.find("reload");
+		cmd.replace(pos, 6, "");
+
+		sAHBotMgr.AHBotReloadAH(pConsole, NULL);
+	}
+
+	if(cmd.find("unload") != std::string::npos)
+	{
+		pos = cmd.find("unload");
+		cmd.replace(pos, 6, "");
+
+		sAHBotMgr.AHBotUnLoadAH(cmd, pConsole, NULL);
+	}
+
+	if(cmd.find("load") != std::string::npos)
+	{
+		pos = cmd.find("load");
+		cmd.replace(pos, 4, "");
+
+		sAHBotMgr.AHBotLoadAH(cmd, pConsole, NULL);
+	}
+
+	return;
+}
+
+uint32 AuctionHouse::CountSpecificItemId(uint32 itemid)
+{
+	uint32 count = 0;
+
+	HM_NAMESPACE::hash_map<uint32, Auction*>::iterator itr = auctions.begin();
+	Auction * auct;
+	for(; itr != auctions.end();)
+	{
+		auct = itr->second;
+		++itr;
+
+		if(auct->pItem->GetEntry() == itemid)
+			++count;
+	}
+
+	return count;
+}
+
+void AuctionHouse::UnloadAHBotAuctions()
+{
+	auctionLock.AcquireReadLock();
+	removalLock.Acquire();
+
+	HM_NAMESPACE::hash_map<uint32, Auction*>::iterator itr = auctions.begin();
+	Auction * auct;
+	for(; itr != auctions.end();)
+	{
+		auct = itr->second;
+		++itr;
+
+		if(auct->Owner == sAHBotMgr.m_PlayerGuid)
+			QueueDeletion(auct, AUCTION_REMOVE_EXPIRED);
+	}
+
+	removalLock.Release();
+	auctionLock.ReleaseReadLock();
+}
+
+uint32 AHBot::GetAnAuctioneer(Player *plr, uint32 AHid)
+{
+	uint32 auctioneer = 0;
+	uint32 ah_faction = 1; // Alliance = 1, Horde = 2, Neutral = 3
+
+	//If no AH id was specified, try to find one...
+	if(AHid == 0)
+	{
+		//if this is not a null session
+		if(plr)
+		{
+			//Get the player's faction in case there is no auctioneer targeted
+			ah_faction = plr->GetTeam(); // _getFaction();
+
+			//see if the player targeted something
+			uint32 guid = GUID_LOPART(plr->GetSelection());
+			if (guid != 0)
+			{
+				Creature *unit = plr->GetMapMgr()->GetCreature(guid);
+				if(unit)
+				{
+					if(unit->auctionHouse != 0)
+						auctioneer = unit->GetEntry();
+				}
+			}
+		}
+	}
+
+	//if nothing was found yet, do a lookup from the database
+	if(auctioneer == 0)
+	{
+		if(AHid != 0)
+			ah_faction = AHid;
+
+		QueryResult *resultAunctioneer2 = WorldDatabase.Query("SELECT `creature_entry` FROM auctionhouse WHERE `group` = %u LIMIT 1", ah_faction);
+		if(resultAunctioneer2)
+		{
+			Field *fields = resultAunctioneer2->Fetch();
+			auctioneer = fields[0].GetUInt32();
+
+			delete resultAunctioneer2;
+		}
+	}
+
+	return auctioneer;
+}
+
+void Container::Create( uint32 itemid, Player *owner, ItemPrototype *proto )
+{
+	m_itemProto = proto;
+	ASSERT(m_itemProto);
+
+	SetUInt32Value( OBJECT_FIELD_ENTRY, itemid );
+	SetUInt64Value( ITEM_FIELD_OWNER, owner->GetGUID() );
+	SetUInt64Value( ITEM_FIELD_CONTAINED, owner->GetGUID() );
+	SetUInt32Value( ITEM_FIELD_STACK_COUNT, 1 );
+	SetUInt32Value( CONTAINER_FIELD_NUM_SLOTS, m_itemProto->ContainerSlots);
+
+	m_Slot = new Item*[m_itemProto->ContainerSlots];
+	memset(m_Slot, 0, sizeof(Item*)*(m_itemProto->ContainerSlots));
+
+	m_owner = owner;
+}
+
+void Item::Create( uint32 itemid, Player *owner, ItemPrototype *proto )
+{
+	SetUInt32Value( OBJECT_FIELD_ENTRY, itemid );
+ 
+	SetUInt64Value( ITEM_FIELD_OWNER, owner->GetGUID() );
+	SetUInt64Value( ITEM_FIELD_CONTAINED, owner->GetGUID() );
+	SetUInt32Value( ITEM_FIELD_STACK_COUNT, 1 );
+
+	m_itemProto = proto;
+	ASSERT(m_itemProto);
+	 
+	SetUInt32Value( ITEM_FIELD_SPELL_CHARGES , m_itemProto->Spells[0].Charges );
+	SetUInt32Value( ITEM_FIELD_SPELL_CHARGES_01 , m_itemProto->Spells[1].Charges );
+	SetUInt32Value( ITEM_FIELD_SPELL_CHARGES_02 , m_itemProto->Spells[2].Charges );
+	SetUInt32Value( ITEM_FIELD_SPELL_CHARGES_03 , m_itemProto->Spells[3].Charges );
+	SetUInt32Value( ITEM_FIELD_SPELL_CHARGES_04 , m_itemProto->Spells[4].Charges );
+	SetUInt32Value( ITEM_FIELD_MAXDURABILITY, m_itemProto->MaxDurability);
+	SetUInt32Value( ITEM_FIELD_DURABILITY, m_itemProto->MaxDurability);
+
+	m_owner = owner;
+	if(m_itemProto->LockId > 1)
+		locked = true;
+	else
+		locked = false;
+}
+
+Item * ObjectMgr::CreateItem(uint32 entry, Player * owner, ItemPrototype * proto)
+{
+	if(proto == 0) return 0;
+
+	if(proto->InventoryType == INVTYPE_BAG)
+	{
+		Container * pContainer = new Container(HIGHGUID_TYPE_CONTAINER,GenerateLowGuid(HIGHGUID_TYPE_CONTAINER));
+		pContainer->Create(entry, owner, proto);
+		pContainer->SetUInt32Value(ITEM_FIELD_STACK_COUNT, 1);
+		return pContainer;
+	}
+	else
+	{
+		Item * pItem = new Item(HIGHGUID_TYPE_ITEM,GenerateLowGuid(HIGHGUID_TYPE_ITEM));
+		pItem->Create(entry, owner, proto);
+		pItem->SetUInt32Value(ITEM_FIELD_STACK_COUNT, 1);
+		return pItem;
+	}
+}
Index: src/ascent-world/AHBot.h
===================================================================
--- src/ascent-world/AHBot.h	(Revision 0)
+++ src/ascent-world/AHBot.h	(Revision 0)
@@ -0,0 +1,100 @@
+/*
+ * Ascent MMORPG Server
+ * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _AHBOT_H
+#define _AHBOT_H
+
+#include "AHBotThread.h"
+#include "BaseConsole.h"
+
+class AHBot;
+struct Auction;
+class AuctionHouse;
+class ChatHandler;
+
+class AHBot : public Singleton <AHBot>
+{
+public:
+
+	bool m_started;
+	AHBOT_THREAD_TASKS m_ThreadTask;
+
+	int m_LogLevel;
+	int m_ClearOnStartup;
+	int m_RefreshInterval;
+	int m_RefreshMinutes;
+	int m_LoadOnStartUp;
+	int m_CleanMailboxes;
+	int m_MinAuctions;
+	string m_Houses;
+	int m_AnnounceLoading;
+	int m_ExpirationMinutes;
+	int m_RandomizeExpiration;
+	string m_IncludeClasses;
+	int m_AllowQuestItems;
+	int m_MinItemLevel;
+	int m_MaxItemLevel;
+	int m_MinPlayerLevel;
+	int m_MaxPlayerLevel;
+	int m_MinItemQuality;
+	int m_MaxItemQuality;
+	int m_MaxItemCount;
+	int m_MaxStack;
+	int m_CustomPrices;
+	float m_BuyoutMultiplier;
+	float m_BidMultiplier;
+	string m_PlayerName;
+	uint32 m_PlayerGuid;
+
+	AuctionHouse * ah;
+	uint32 itemsToAdd;
+	Player * plr;
+
+	void LoadSettings();
+	void SetThreadTask(AHBOT_THREAD_TASKS task);
+	AHBOT_THREAD_TASKS GetThreadTask();
+	bool GetThreadTask(AHBOT_THREAD_TASKS task);
+	void ModifyRemoveAuction(AuctionHouseDBC * dbc, Auction * auct);
+
+	uint32 AHBot::GetAnAuctioneer(Player *plr, uint32 AHid);
+
+	void AHBotSendMessage(char msg, BaseConsole * pConsole, WorldSession *m_session);
+	void AHBotConsoleCommands(BaseConsole * pConsole, int argc, string args);
+	bool AHBotAutoAH(BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotClearAH(BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotConfigAH(BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotCountAH(BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotListAH(BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotLogLevelAH(string args, BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotLoadAH(string args, BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotPreloadAH(string args, BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotReloadAH(BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotUnLoadAH(string args, BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotTimeAH(BaseConsole * pConsole, WorldSession *m_session);
+	bool AHBotRefreshMinutesAH(string args, BaseConsole * pConsole, WorldSession *m_session);
+
+private:
+	void OnStart();
+
+public:
+};
+
+#define sAHBotMgr AHBot::getSingleton()
+
+#endif
Index: src/ascent-world/AHBotThread.cpp
===================================================================
--- src/ascent-world/AHBotThread.cpp	(Revision 0)
+++ src/ascent-world/AHBotThread.cpp	(Revision 0)
@@ -0,0 +1,973 @@
+/*
+ * Ascent MMORPG Server
+ * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "StdAfx.h"
+
+#ifdef WIN32
+static HANDLE m_abortEvent = INVALID_HANDLE_VALUE;
+#endif
+
+inline std::string MyConvertToString(const int arg)
+{
+	stringstream out;
+	out << arg;
+	return out.str();
+}
+
+inline std::string MyConvertToString(const uint32 arg)
+{
+	stringstream out;
+	out << arg;
+	return out.str();
+}
+
+inline std::string MyConvertToString(const float arg)
+{
+	stringstream out;
+	out << arg;
+	return out.str();
+}
+
+AHBotUpdaterThread::AHBotUpdaterThread()
+{
+	m_running = true;
+	m_dirty = false;
+}
+
+AHBotUpdaterThread::~AHBotUpdaterThread()
+{
+
+}
+
+void AHBotUpdaterThread::load_threadsettings()
+{
+	if(sLog.m_screenLogLevel >= 2)
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), load_threadsettings().", GetThreadId());
+
+	while(!sAHBotMgr.GetThreadTask(AHBOT_STARTUP))
+	{
+		// Sleep/wait for 10,000 milliseconds (10 seconds)
+#ifdef WIN32
+		WaitForSingleObject(m_abortEvent, 10000);
+#else
+		Sleep(10000);
+#endif
+	}
+
+	m_LogLevel = sAHBotMgr.m_LogLevel;
+	m_ClearOnStartup = sAHBotMgr.m_ClearOnStartup;
+	m_RefreshInterval = sAHBotMgr.m_RefreshInterval;
+	m_RefreshMinutes = sAHBotMgr.m_RefreshMinutes;
+	m_LoadOnStartUp = sAHBotMgr.m_LoadOnStartUp;
+	m_CleanMailboxes = sAHBotMgr.m_CleanMailboxes;
+	m_MinAuctions = sAHBotMgr.m_MinAuctions;
+	m_Houses = sAHBotMgr.m_Houses;
+	m_AnnounceLoading = sAHBotMgr.m_AnnounceLoading;
+	m_ExpirationMinutes = sAHBotMgr.m_ExpirationMinutes;
+	m_RandomizeExpiration = sAHBotMgr.m_RandomizeExpiration;
+	m_IncludeClasses = sAHBotMgr.m_IncludeClasses;
+	m_AllowQuestItems = sAHBotMgr.m_AllowQuestItems;
+	m_MinItemLevel = sAHBotMgr.m_MinItemLevel;
+	m_MaxItemLevel = sAHBotMgr.m_MaxItemLevel;
+	m_MinPlayerLevel = sAHBotMgr.m_MinPlayerLevel;
+	m_MaxPlayerLevel = sAHBotMgr.m_MaxPlayerLevel;
+	m_MinItemQuality = sAHBotMgr.m_MinItemQuality;
+	m_MaxItemQuality = sAHBotMgr.m_MaxItemQuality;
+	m_MaxItemCount = sAHBotMgr.m_MaxItemCount;
+	m_MaxStack = sAHBotMgr.m_MaxStack;
+	m_CustomPrices = sAHBotMgr.m_CustomPrices;
+	m_BuyoutMultiplier = sAHBotMgr.m_BuyoutMultiplier;
+	m_BidMultiplier = sAHBotMgr.m_BidMultiplier;
+	m_PlayerName = sAHBotMgr.m_PlayerName;
+	m_PlayerGuid = sAHBotMgr.m_PlayerGuid;
+
+	currenttime = UNIXTIME;
+
+	last_mail_time = 0;
+	last_update_time = 0;
+    last_playeritems_time = 0;
+}
+
+void AHBotUpdaterThread::terminate()
+{
+	Log.Notice("AHBotUpdaterThread", "Thread('%u'), terminate()", GetThreadId());
+
+	m_running = false;
+#ifdef WIN32
+	SetEvent(m_abortEvent);
+#endif
+}
+
+bool AHBotUpdaterThread::has_mail_expired(time_t now_time, time_t last_time)
+{
+	// Time is in seconds, refreshInterval is in seconds
+	// the sleep interval for this thread is 60 seconds, so we subtract that interval
+	if(((uint32)now_time - (uint32)last_time) > (600 - 60)) return true;
+
+	return false;
+}
+
+bool AHBotUpdaterThread::has_update_expired(time_t now_time, time_t last_time)
+{
+	// Time is in seconds, refreshInterval is in hours, so we multiply by 3600 seconds in one hour
+	// the sleep interval for this thread is 60 seconds, so we subtract that interval
+	//if(((uint32)now_time - (uint32)last_time) > ((m_RefreshInterval * 3600) - 60)) return true;
+
+	// Time is in seconds, refreshInterval is in minutes, so we multiply by 60 seconds in one minute
+	// the sleep interval for this thread is 60 seconds, so we subtract that interval
+	if(((uint32)now_time - (uint32)last_time) > (((uint32)m_RefreshMinutes * 60) - 60)) return true;
+
+	return false;
+}
+
+bool AHBotUpdaterThread::has_playeritems_expired(time_t now_time, time_t last_time)
+{
+	// Time is in seconds, refreshInterval is in seconds
+	// the sleep interval for this thread is 60 seconds, so we subtract that interval
+	if(((uint32)now_time - (uint32)last_time) > (3600 - 60)) return true;
+
+	return false;
+}
+
+bool AHBotUpdaterThread::run()
+{
+	Log.Notice("AHBotUpdaterThread", "Thread('%u'), run()", GetThreadId());
+
+	m_busy = false;
+#ifdef WIN32
+	m_abortEvent = CreateEvent(NULL, NULL, FALSE, NULL);
+#endif
+	
+	load_threadsettings();
+	
+	if(m_PlayerGuid == 0)
+	{
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), run(), encountered m_PlayerGuid == 0", GetThreadId());
+		m_running = false;
+		terminate();
+	}
+
+	if(m_ClearOnStartup == 1)
+		clear_auctionhouses();
+
+	while(ThreadState != THREADSTATE_TERMINATE)
+	{
+		if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+			Log.Notice("AHBotUpdaterThread", "Thread('%u'), Looping, task('%u').", GetThreadId(), sAHBotMgr.GetThreadTask());
+
+		m_busy = true;
+
+		currenttime = UNIXTIME;
+
+		// Was a reload of the settings triggered?
+		if((m_running == true) && (sAHBotMgr.GetThreadTask(AHBOT_SETTINGS)))
+		{
+			load_threadsettings();
+			sAHBotMgr.SetThreadTask(AHBOT_COMPLETE);
+		}
+
+		// Was an AH update triggered outside the normally scheduled cycle?
+		if((m_running == true) && (sAHBotMgr.GetThreadTask(AHBOT_UPDATE)))
+		{
+			update_auctionhouse();
+			sAHBotMgr.SetThreadTask(AHBOT_COMPLETE);
+		}
+
+		// Was an AH clear triggered?
+		if((m_running == true) && (sAHBotMgr.GetThreadTask(AHBOT_CLEAR)))
+		{
+			clear_auctionhouses();
+			sAHBotMgr.SetThreadTask(AHBOT_COMPLETE);
+		}
+
+		// Was an AH pre-load triggered?
+		if((m_running == true) && (sAHBotMgr.GetThreadTask(AHBOT_PRELOAD)))
+		{
+			preload_auctionhouse(sAHBotMgr.ah);
+			sAHBotMgr.SetThreadTask(AHBOT_COMPLETE);
+		}
+
+		// Was an AH load triggered?
+		if((m_running == true) && (sAHBotMgr.GetThreadTask(AHBOT_LOAD)))
+		{
+			load_auctionhouse(sAHBotMgr.plr, sAHBotMgr.ah, sAHBotMgr.itemsToAdd);
+			sAHBotMgr.SetThreadTask(AHBOT_COMPLETE);
+		}
+
+		// Was an AH unload triggered?
+		if((m_running == true) && (sAHBotMgr.GetThreadTask(AHBOT_UNLOAD)))
+		{
+			unload_auctionhouse(sAHBotMgr.plr, sAHBotMgr.ah);
+			sAHBotMgr.SetThreadTask(AHBOT_COMPLETE);
+		}
+
+		// Is it time for the next mailbox update?
+		if ( m_CleanMailboxes == 1)
+		{
+			if ( ( m_running == true ) && ( has_mail_expired(currenttime, last_mail_time) ) )
+				clean_mailboxes();
+		}
+
+		// Is it time for the next regular auction house update?
+		if((m_running == true) && (has_update_expired(currenttime, last_update_time)))
+			update_auctionhouse();
+
+		// Is it time for the next playeritems update?
+		if((m_running == true) && (has_playeritems_expired(currenttime, last_playeritems_time)))
+			clean_playeritems();
+
+		m_busy = false;
+
+		// Was there a shutdown event?
+		if(sMaster.m_ShutdownEvent == true)
+			break;
+
+		if(ThreadState == THREADSTATE_TERMINATE)
+			break;
+
+		// Sleep/wait for 60,000 milliseconds (1 minute)
+#ifdef WIN32
+		WaitForSingleObject(m_abortEvent, 60000);
+#else
+		Sleep(60000);
+#endif
+		if(!m_running)
+			break;
+	}
+
+#ifdef WIN32
+	CloseHandle(m_abortEvent);
+#endif
+
+	return true;
+}
+
+void AHBotUpdaterThread::startup_auctionhouse(uint32 ahid, uint32 itemThreshold)
+{
+	if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), startup_auctionhouse('%u','%u')", GetThreadId(), ahid, itemThreshold);
+
+	if((itemThreshold <= 0) || (ahid <= 0))
+		return;
+
+	uint32 auctioneer = 0;
+
+	// auctioneer was renamed to creature_entry and AHid was renamed to group in revision 2311
+	QueryResult *resultAunctioneer = WorldDatabase.Query("SELECT `creature_entry` FROM auctionhouse WHERE `group` = %u LIMIT 1", ahid);
+	if(resultAunctioneer)
+	{
+		Field *fields = resultAunctioneer->Fetch();
+		auctioneer = fields[0].GetUInt32();
+
+		delete resultAunctioneer;
+	}
+
+	if(auctioneer <= 0)
+	{
+		sLog.outString("LoadAHBotAuctionsOnStartup: Unable to get an auctioneer for auction house '%u'", ahid);
+		return;
+	}
+
+	// Create a reference to the Auction House
+	AuctionHouse * ah = sAuctionMgr.GetAuctionHouse(auctioneer);
+	if(!ah)
+	{
+		sLog.outString("LoadAHBotAuctionsOnStartup: Unable to access auction house '%u' using auctioneer '%u'", ahid, auctioneer);
+		return;
+	}
+
+	// Pre-load the auction house with items stored in a table
+	if(!preload_auctionhouse(ah))
+	{
+		sLog.outString("LoadAHBotAuctionsOnStartup: Failed to pre-load the auction house '%u'", ahid);
+	}
+
+	// Get the current number of auction in the AH
+	uint32 currentAuctions = 0;
+	QueryResult *resultAuctions = CharacterDatabase.Query("SELECT Count(auctionid) FROM auctions WHERE auctionhouse = %u", ahid);
+	if(resultAuctions)
+	{
+		Field *fields = resultAuctions->Fetch();
+		currentAuctions = fields[0].GetUInt32();
+
+		delete resultAuctions;
+	}
+
+	// Does the current number of auctions meet or exceed the current configured threshold?
+	if(currentAuctions >= itemThreshold)
+		return;
+
+	uint32 itemsToAdd = (itemThreshold - currentAuctions);
+	if(itemsToAdd <= 0)
+		return;
+
+	if(!load_auctionhouse(ah, itemsToAdd))
+	{
+		sLog.outString("LoadAHBotAuctionsOnStartup: Failed to load the auction house '%u'", ahid);
+		return;
+	}
+
+	return;
+}
+
+void AHBotUpdaterThread::update_auctionhouse()
+{
+	if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), update_auctionhouse()", GetThreadId());
+
+	if((m_LoadOnStartUp == 1) && (m_MinAuctions >= 1))
+	{
+		if(m_Houses.find("0") != string::npos)	startup_auctionhouse(0, m_MinAuctions);
+		if(m_Houses.find("1") != string::npos)	startup_auctionhouse(1, m_MinAuctions);
+		if(m_Houses.find("2") != string::npos)	startup_auctionhouse(2, m_MinAuctions);
+		if(m_Houses.find("3") != string::npos)	startup_auctionhouse(3, m_MinAuctions);
+		if(m_Houses.find("4") != string::npos)	startup_auctionhouse(4, m_MinAuctions);
+		if(m_Houses.find("5") != string::npos)	startup_auctionhouse(5, m_MinAuctions);
+		if(m_Houses.find("6") != string::npos)	startup_auctionhouse(6, m_MinAuctions);
+		if(m_Houses.find("7") != string::npos)	startup_auctionhouse(7, m_MinAuctions);
+		if(m_Houses.find("8") != string::npos)	startup_auctionhouse(8, m_MinAuctions);
+		if(m_Houses.find("9") != string::npos)	startup_auctionhouse(9, m_MinAuctions);
+	}
+
+	// Update the last auction house update time since it occurs on a recurring cycle
+	last_update_time = currenttime;
+
+	return;
+}
+
+bool AHBotUpdaterThread::add_item(Player * tmpPlr, AuctionHouse * ah, uint32 itemToAdd, uint32 auctionExpire)
+{
+	if((m_LogLevel >= 2) && (m_PlayerGuid == 0))
+	{
+		sLog.outString("AHBotUpdaterThread::add_item() encountered m_PlayerGuid == 0");
+		return false;
+	}
+
+	bool ok2AddItem = false;
+
+	//If we can lookup the entry, it is a good itemid
+	ItemPrototype* it = ItemPrototypeStorage.LookupEntry(itemToAdd);
+	if (it)
+	{
+		ok2AddItem = true;
+
+		if((ok2AddItem) && (m_IncludeClasses != ""))
+		{
+			string includeClasses = "," + m_IncludeClasses + ","; // tack a comma at the beginning and end - searching for 1 with the comma at the end - prevents finding class 1 when 10,11 are included
+
+			string sClass = MyConvertToString(it->Class) + ",";
+
+			if(!includeClasses.find(sClass)) // did we find the class in the list of included classes?
+			{
+				ok2AddItem = false;
+				if(m_LogLevel >= 2)
+					sLog.outString("AHBot Rejected '%u' - class '%u' ('%s') was not in '%s'", it->ItemId, it->Class, sClass.c_str(), includeClasses.c_str());
+			}
+		}
+
+		// This should all be handled by the loops that call this routine using trackItemCount[]
+		// Does the config file specify that we need to count the number of auctions with this item id?
+		//if((ok2AddItem) && (m_MaxItemCount > 0))
+		//{
+		//	if((uint32)m_MaxItemCount <= ah->CountSpecificItemId(it->ItemId))
+		//	{
+		//		ok2AddItem = false;
+		//		if(m_LogLevel >= 2)
+		//			sLog.outString("AHBot Rejected item id '%u' because MaxItemCount was exceeded", it->ItemId);
+		//	}
+		//}
+
+		// Exclude items that are needed by a quest
+		if((m_AllowQuestItems == 0) && (it->QuestId != 0))
+			ok2AddItem = false;
+
+		// Exclude items that don't meet the level standards
+		if((it->ItemLevel < (uint32)m_MinItemLevel) || (it->ItemLevel > (uint32)m_MaxItemLevel))
+			ok2AddItem = false;
+			
+		// Exclude items that don't meet the player level standards
+		if((it->RequiredLevel < (uint32)m_MinPlayerLevel) || (it->RequiredLevel > (uint32)m_MaxPlayerLevel))
+			ok2AddItem = false;
+			
+		// Exclude items that don't meet the quality standards
+		if((it->Quality < (uint32)m_MinItemQuality) || (it->Quality > (uint32)m_MaxItemQuality))
+			ok2AddItem = false;
+			
+		// Exclude items with an extended cost
+//FIX		if(it->ItemExtendedCostEntry != 0)
+//			ok2AddItem = false;
+
+		// Exclude these bonding types
+		if((it->Bonding == ITEM_BIND_ON_PICKUP) || (it->Bonding == ITEM_BIND_QUEST) || (it->Bonding == ITEM_BIND_QUEST2))
+			ok2AddItem = false;
+
+		// Is it still ok to add them item?
+		if(ok2AddItem)
+		{
+			Item *itemTmp;
+			itemTmp = objmgr.CreateItem(itemToAdd, tmpPlr, it);
+
+			if(itemTmp)
+			{
+				uint32 stackCount = 1;
+
+				// Can we stack more than 1 item at a time?
+				if(it->MaxCount > 1)
+				{
+					// How many items should be in the stack?
+					switch (m_MaxStack)
+					{
+					  case 0: // Only 1 of an item
+						stackCount = 1;
+						break;
+					  case 1: // Random number between 1 and maxmimum
+						stackCount = RandomUInt(it->MaxCount); // find a random number
+						break;
+					  case 2: // Maximum possible for the stack
+						stackCount = it->MaxCount;
+						break;
+					  default: // Default to maximum possible
+						stackCount = it->MaxCount;
+					}
+
+					if(stackCount <= 0)
+						stackCount = 1;
+				}
+
+				// Is this a stackable item?
+				itemTmp->SetUInt32Value(ITEM_FIELD_STACK_COUNT, stackCount);
+
+				// This determines whether a chargeable item is expendable or non-expendable
+				// Is this an expendable chargeable item?
+				if(it->Spells[0].Charges < 0) // EXPENDABLE ITEM
+				{
+					//i_caster->ModUInt32Value(ITEM_FIELD_SPELL_CHARGES, 1); // remove 1 charge for an expendable item
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES, -2); //it->Spells[0].Charges
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_01, it->Spells[1].Charges );
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_02, it->Spells[2].Charges );
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_03, it->Spells[3].Charges );
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_04, it->Spells[4].Charges );
+				}
+
+				// Is this a non-expendable chargeable item?
+				if(it->Spells[0].Charges > 0) // NON-EXPENDABLE ITEM
+				{
+					// i_caster->ModUInt32Value(ITEM_FIELD_SPELL_CHARGES, -1); // remove 1 charge for a non-expendable item
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES, 2); //it->Spells[0].Charges
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_01, it->Spells[1].Charges );
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_02, it->Spells[2].Charges );
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_03, it->Spells[3].Charges );
+					itemTmp->SetUInt32Value(ITEM_FIELD_SPELL_CHARGES_04, it->Spells[4].Charges );
+				}
+
+				// Remove the item from the world and the owner and save to database
+				itemTmp->RemoveFromWorld();
+				itemTmp->SetOwner(0);
+				itemTmp->SaveToDB(INVENTORY_SLOT_NOT_SET, 0, true, NULL);
+
+				uint32 buyout = 0; // the calculated buyout price of the item
+				uint32 bid = 0; // the calculated bid price of the item
+
+				// Calculate the standard buyout price first
+				if(it->BuyPrice == 0)
+					buyout = (uint32)(it->SellPrice * m_BuyoutMultiplier * 5); // Buyprice is typically 5X the sellprice
+				else
+					buyout = (uint32)(it->BuyPrice * m_BuyoutMultiplier);	
+
+				if(m_CustomPrices == 1)
+				{
+					// We're using a custom buyout price based on the auction_house_statistics table
+					QueryResult *resultCustomPrices = CharacterDatabase.Query("SELECT avgPrice FROM auction_house_statistics WHERE entry = %u",itemToAdd);
+					if(resultCustomPrices)
+					{
+						Field *CustomPrices = resultCustomPrices->Fetch();
+						buyout = CustomPrices[0].GetUInt32();
+					}
+					delete resultCustomPrices;
+				}
+				// buyout of 0 or less confuses the AH
+				if(buyout <= 0)
+					buyout = 1;
+
+				// multiply the buyout by the number of items in the stack
+				buyout = (uint32)(buyout * stackCount);
+
+				// Calculate the bid price, including the number of items in the stack
+				bid = (uint32)(it->BuyPrice * m_BidMultiplier * stackCount);
+				if(bid < 0)
+					bid = 0;
+
+				// The buyout always needs to be larger than the bid
+				if(buyout <= bid)
+					buyout = bid + 1;
+
+				// Create auction structure
+				Auction * auct = new Auction;
+				auct->BuyoutPrice = buyout;
+				auct->Deleted = false;
+				auct->DeletedReason = 0;
+				auct->DepositAmount = 1;
+				auct->ExpiryTime = auctionExpire;
+				auct->HighestBid = bid;
+				if(bid >= 1)
+					auct->HighestBidder = m_PlayerGuid;
+				else
+					auct->HighestBidder = 0;
+				auct->Id = sAuctionMgr.GenerateAuctionId();
+				auct->Owner = m_PlayerGuid;
+				auct->pItem = itemTmp;
+
+				// Add to the auction house.
+				ah->AddAuction(auct);
+				auct->SaveToDB(ah->GetID());
+			}
+		}
+	}
+
+	return ok2AddItem;
+}
+
+bool AHBotUpdaterThread::preload_auctionhouse(AuctionHouse * ah)
+{
+	char msg[200];
+
+	if((m_LogLevel >= 2) && (m_PlayerGuid == 0))
+	{
+		sLog.outString("AHBotUpdaterThread::preload_auctionhouse() encountered m_PlayerGuid == 0");
+		return false;
+	}
+
+	if(!ah)
+	{
+		if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+			Log.Notice("AHBotUpdaterThread", "Thread('%u'), preload_auctionhouse(INVALID_AH)", GetThreadId());
+		return false;
+	}
+
+	if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), preload_auctionhouse('%u')", GetThreadId(), ah->GetID());
+
+	uint32 currentTime = getMSTime();
+
+	// If configured to make a world announce, then this is the time...
+	if( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot is attempting to pre-load AH '%u'", ah->GetID());
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+	}
+
+	// Get the current pre-defined items to load into the auction house
+	QueryResult *resultAuctions = CharacterDatabase.Query("SELECT itemid, itemcount FROM ahbotitems WHERE auctionhouse = %u", ah->GetID());
+	if(resultAuctions)
+	{
+		// We only need a dummy player, the item is quickly taken away from the player and placed in the auction house
+		Player * tmpPlr = new Player(m_PlayerGuid);
+
+		// Save the current MaxStack setting
+		uint32 previousStack = m_MaxStack;
+
+		m_MaxStack = 2; // Force to a full stack of each item
+
+		uint32 auctionExpire = (uint32)UNIXTIME + (uint32)(m_ExpirationMinutes * 60); // the time the auctions will expire
+
+		do
+		{
+			Field *fields = resultAuctions->Fetch();
+			uint32 itemId = fields[0].GetUInt32();
+			uint32 itemCount = fields[1].GetUInt32();
+
+			uint32 itemExisting = ah->CountSpecificItemId(itemId);
+
+			if(itemExisting >= itemCount)
+				itemCount = 0;
+
+			if(itemCount > 0)
+			{
+				for (uint32 i = 0; i < itemCount; i++)
+				{
+					add_item(tmpPlr, ah, itemId, auctionExpire);
+				}
+			}
+
+		}while (resultAuctions->NextRow());
+
+		delete resultAuctions;
+
+		// Restore the previous MaxStack setting
+		m_MaxStack = previousStack;
+
+		//Remove the dummy player from the world
+		tmpPlr->RemoveFromWorld();
+	}
+
+	// If configured to make a world announce, then this is the time...
+	if ( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot finished pre-loading AH '%u' in %u ms", ah->GetID(), getMSTime() - currentTime);
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+	}
+
+	return true;
+}
+
+bool AHBotUpdaterThread::load_auctionhouse(Player * plr, AuctionHouse * ah, uint32 itemsToAdd)
+{
+	char msg[200];
+
+	if((m_LogLevel >= 2) && (m_PlayerGuid == 0))
+	{
+		sLog.outString("AHBotUpdaterThread::load_auctionhouse() encountered m_PlayerGuid == 0");
+		return false;
+	}
+
+	bool finished = load_auctionhouse(ah, itemsToAdd);
+
+	if(finished)
+		snprintf(msg, 200, "AHBot finished re-loading AH '%u'", ah->GetID());
+	else
+		snprintf(msg, 200, "AHBot did NOT finish re-loading AH '%u'", ah->GetID());
+
+	if(plr)
+	{
+		if(plr->IsInWorld())
+			plr->GetSession()->SendNotification(msg);
+		else
+			sLog.outString(msg);
+	}
+
+	return finished;
+}
+
+bool AHBotUpdaterThread::load_auctionhouse(AuctionHouse * ah, uint32 itemsToAdd)
+{
+	char msg[200];
+
+	if ( ( m_LogLevel >= 2 ) && ( m_PlayerGuid == 0 ) )
+	{
+		sLog.outString("AHBotUpdaterThread::load_auctionhouse() encountered m_PlayerGuid == 0");
+		return false;
+	}
+
+	if ( ( sLog.m_screenLogLevel >= 2 ) || ( m_LogLevel >= 1 ) )
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), load_auctionhouse('%u', '%u')", GetThreadId(), ah->GetID(), itemsToAdd);
+
+	if ( itemsToAdd <= 0 )
+		return false;
+
+	uint32 currentTime = getMSTime();
+
+	// If configured to make a world announce, then this is the time...
+	if ( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot is attempting to re-load AH '%u'", ah->GetID());
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if ( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+	}
+
+	//Get the current maximum entry in the items table
+	uint32 maxItemId = 100000;
+	QueryResult *resultMaxId = WorldDatabase.Query("SELECT MAX(entry) FROM items");
+	if ( resultMaxId )
+	{
+		Field *fields = resultMaxId->Fetch();
+		maxItemId = fields[0].GetUInt32();
+
+		delete resultMaxId;
+	}
+
+	uint32 randDatabaseValue = 0; // the random value from the database
+	uint32 maxRandDataBaseVal = 0; // the maximum random value in the dayabase
+	uint32 maxCountOfRandomItem = 0; // the maximum stack value
+
+	// This is supposed to place the table/array into the heap and bypass stack limitations???
+	uint8 *trackItemCount;
+	//trackItemCount = new uint8[500000];
+
+	try
+		{
+			trackItemCount = new uint8[500000];
+		}
+
+		catch (std::bad_alloc & BadAllocException)
+		{
+			Log.Notice("AHBotUpdaterThread", "Thread('%u'), load_auctionhouse - trackItemCount exception was caught properly.", GetThreadId());
+			trackItemCount = NULL;
+		}
+		catch (...)
+		{
+			Log.Notice("AHBotUpdaterThread", "Thread('%u'), load_auctionhouse - trackItemCount exception was NOT caught properly.", GetThreadId());
+			trackItemCount = NULL;
+		}
+
+	// Was memory successfully allocated for the table/array?
+	if ( ( trackItemCount != NULL ) && ( m_MaxItemCount > 0 ) )
+	{
+		//fill with the m_MaxItemCount from ascent.conf
+		for( uint32 i = 0; i < 500000; i++ )
+			trackItemCount[i] = m_MaxItemCount; // m_MaxItemCount may or may not be 0
+	}
+
+	if ( m_CustomPrices == 1 )
+	{
+		QueryResult *resultmaxRandDataBaseVal = CharacterDatabase.Query("SELECT SUM(volume) FROM auction_house_statistics");
+		if ( resultmaxRandDataBaseVal )
+		{
+			Field *fields = resultmaxRandDataBaseVal->Fetch();
+			maxRandDataBaseVal = fields[0].GetUInt32();
+
+			delete resultmaxRandDataBaseVal;
+		}
+	}
+
+	if ( m_LogLevel >= 2 )
+		sLog.outString("AHBot is using maximum item id '%u'", maxItemId);
+
+	// We only need a dummy player, the item is quickly taken away from the player and placed in the auction house
+	Player * tmpPlr = new Player( m_PlayerGuid);
+
+	uint32 itemLoopMax = itemsToAdd * 1000; // I know the random number generator is going to hit on some missing items, so lets limit the amount of looping it does
+	uint32 itemCount = 0; // the number of auction items actually added
+	uint32 itemLoops = 0; // the number of times the loops has executed, whether or not an item was added
+	uint32 itemRandom = 0; // the random item id to be added
+
+	uint32 maxAuctionTime = (uint32)(m_ExpirationMinutes * 60); // the configured maximum length of an auction
+	uint32 minAuctionTime = (uint32)(maxAuctionTime / 8); // the derived minimum length of an auction
+
+	if ( minAuctionTime < 1800 )
+		minAuctionTime = 1800; // 30 minutes
+
+	if ( minAuctionTime > maxAuctionTime )
+		maxAuctionTime = minAuctionTime * 2;
+
+	uint32 minExpireTime = (uint32)UNIXTIME + minAuctionTime;
+	uint32 maxExpireTime = (uint32)UNIXTIME + maxAuctionTime;
+
+	uint32 auctionExpire = maxExpireTime; // the default is the the actual maximum time the auctions will expire
+	uint32 randomExpire = 0;
+
+	uint32 diffExpireTime = maxExpireTime - minExpireTime;
+
+	while ( ( itemCount < itemsToAdd ) && ( itemLoops <= itemLoopMax ) )
+	{
+		itemLoops++;
+
+		if ( itemCount != itemsToAdd )
+		{
+			itemRandom = RandomUInt(maxItemId); // find a random number first
+
+			// Are we using custom prices? Let's wee if we can find a random item from the database instead
+			if ( m_CustomPrices == 1 )
+			{
+				randDatabaseValue = RandomUInt(maxRandDataBaseVal); // find a random number to pick from the database
+				
+				// Find a matching item from the database
+				QueryResult *resultMatchingItem = CharacterDatabase.Query("SELECT entry, stack FROM auction_house_statistics WHERE `min` <= %u AND `max` >= %u", randDatabaseValue, randDatabaseValue);
+				if ( resultMatchingItem )
+				{
+					Field *fields = resultMatchingItem->Fetch();
+					itemRandom = fields[0].GetUInt32();
+					maxCountOfRandomItem = fields[1].GetUInt32();
+					delete resultMatchingItem;
+				}
+
+				// Was memory successfully allocated for the tracking table?
+				if ( ( trackItemCount != NULL )  && ( m_MaxItemCount > 0 ) && ( itemRandom >= 0 ) && ( itemRandom <= 500000 ) && ( maxCountOfRandomItem > 1 ) )
+				{
+					//This item has just been added so setup the counter that we will decrement every time a new one is added (c = (a>b) ? a : b;)
+					if ( ( trackItemCount[itemRandom] == m_MaxItemCount ) && ( maxCountOfRandomItem < m_MaxItemCount ) )
+							trackItemCount[itemRandom] = maxCountOfRandomItem;
+
+				} // (( trackItemCount != NULL ) && ( itemRandom >= 0 ) && ( itemRandom <= 500000 ) && ( maxCountOfRandomItem > 1 ))
+
+			} // ( m_CustomPrices == 1 )
+
+			// Was memory successfully allocated for the tracking table and are we tacking the item count?
+			if ( ( trackItemCount != NULL )  && ( m_MaxItemCount > 0 ) )
+			{
+				// Has this item already been added to the auction house during this session the maximum number of times?
+				if ( trackItemCount[itemRandom] == 0 )
+				{
+					if ( m_LogLevel >= 2 )
+						sLog.outString("AHBot Rejected item id '%u' because MaxItemCount was exceeded", itemRandom);
+					continue;
+				}
+				else
+					trackItemCount[itemRandom]--; //  decrement the tracking counter
+			}
+
+			if ( ( m_RandomizeExpiration == 1 ) && ( diffExpireTime > 0 ) )
+			{
+				randomExpire = RandomUInt(diffExpireTime); // find a random number
+				auctionExpire = minExpireTime + randomExpire;
+			}
+
+			if ( add_item(tmpPlr, ah, itemRandom, auctionExpire) )
+				itemCount++;
+		}
+	}
+
+	// Release the table/array and the memory associated with it
+	if ( trackItemCount != NULL )
+		delete [] trackItemCount;
+
+	//Remove the dummy player from the world
+	tmpPlr->RemoveFromWorld();
+
+	// If configured to make a world announce, then this is the time...
+	if ( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot finished re-loading AH '%u' in %u ms", ah->GetID(), getMSTime() - currentTime);
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if ( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+	}
+
+	return true;
+}
+
+void AHBotUpdaterThread::unload_auctionhouse(Player * plr, AuctionHouse * ah)
+{
+	char msg[200];
+
+	if((m_LogLevel >= 2) && (m_PlayerGuid == 0))
+	{
+		sLog.outString("AHBotUpdaterThread::unload_auctionhouse() encountered m_PlayerGuid == 0");
+		return;
+	}
+
+	if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), unload_auctionhouse('%u')", GetThreadId(), ah->GetID());
+
+	uint32 currentTime = getMSTime();
+
+	// If configured to make a world announce, then this is the time...
+	if ( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot is attempting to unload AH '%u'", ah->GetID());
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+	}
+
+	// Having this in the AH class makes it easier to implement
+	ah->UnloadAHBotAuctions();
+
+	// Trigger the auction house deletion queue before the normal cycle
+	ah->UpdateDeletionQueue();
+
+	// If configured to make a world announce, then this is the time...
+	if ( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot finished unloading AH '%u' in %u ms", ah->GetID(), getMSTime() - currentTime);
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+
+		if(plr)
+		{
+			if(plr->IsInWorld())
+				plr->GetSession()->SendNotification(msg);
+		}
+		else
+			sLog.outString(msg);
+	}
+
+	return;
+}
+
+void AHBotUpdaterThread::clean_mailboxes()
+{
+	if ( ( m_PlayerGuid != 0 ) && ( m_CleanMailboxes == 1 ) )
+	{
+		// If any mail slips through to the AHBot character, then delete it
+		CharacterDatabase.Execute("DELETE FROM mailbox WHERE player_guid = %u AND message_type = %u", m_PlayerGuid, AUCTION);
+
+		if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+			Log.Notice("AHBotUpdaterThread", "Thread('%u'), clean_mailboxes(%u)", GetThreadId(), m_PlayerGuid);
+	}
+
+	// Update the last time the mailbox was updated since it executes on a recurring cycle
+	last_mail_time = currenttime;
+
+	return;
+}
+
+void AHBotUpdaterThread::clean_playeritems()
+{
+	if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), clean_playeritems()", GetThreadId());
+
+	// Update the last time the playeritems was updated since it executes on a recurring cycle
+	last_playeritems_time = currenttime;
+
+	return;
+}
+
+void AHBotUpdaterThread::clear_auctionhouses()
+{
+	char msg[200];
+
+	if((sLog.m_screenLogLevel >= 2) || (m_LogLevel >= 1))
+		Log.Notice("AHBotUpdaterThread", "Thread('%u'), clear_auctionhouses()", GetThreadId());
+
+	// If configured to make a world announce, then this is the time...
+	if ( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot is attempting to clear all auction houses");
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+	}
+
+	CharacterDatabase.Execute("DELETE FROM auctions");
+	CharacterDatabase.Execute("DELETE FROM playeritems WHERE ownerguid = 0");
+
+	// Refresh the auction houses now that they are empty
+	sAuctionMgr.LoadAuctionHouses();
+
+	// If configured to make a world announce, then this is the time...
+	if ( m_AnnounceLoading == 1 )
+	{
+		snprintf(msg, 200, "AHBot has cleared and reloaded all auction houses");
+
+		sWorld.SendWorldWideScreenText(msg); // send message to players
+
+		if( m_LogLevel >= 1 )
+			sLog.outString(msg); // send message to console
+	}
+}
Index: src/ascent-world/AHBotThread.h
===================================================================
--- src/ascent-world/AHBotThread.h	(Revision 0)
+++ src/ascent-world/AHBotThread.h	(Revision 0)
@@ -0,0 +1,106 @@
+/*
+ * Ascent MMORPG Server
+ * Copyright (C) 2005-2007 Ascent Team <http://www.ascentemu.com/>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _AHBOTTHREAD_H
+#define _AHBOTTHREAD_H
+
+#include "AHBot.h"
+#include "../../src/ascent-world/Master.h"
+#include "../ascent-shared/Threading/Condition.h"
+
+class AuctionHouse;
+
+enum AHBOT_THREAD_TASKS
+{
+	AHBOT_SLEEPING  = 0,
+	AHBOT_STARTUP	= 1,
+	AHBOT_UPDATE	= 2,
+	AHBOT_PRELOAD	= 3,
+	AHBOT_LOAD		= 4,
+	AHBOT_UNLOAD	= 5,
+	AHBOT_COMPLETE  = 6,
+	AHBOT_CLEAR     = 7,
+	AHBOT_SETTINGS  = 8,
+};
+
+class AHBotUpdaterThread : public CThread
+{
+	bool m_running;
+	bool m_busy;
+	bool m_dirty;
+
+	time_t currenttime;
+	time_t last_update_time;
+	time_t last_mail_time;
+	time_t last_playeritems_time;
+
+	int m_LogLevel;
+	int m_ClearOnStartup;
+	int m_RefreshInterval;
+	int m_RefreshMinutes;
+	int m_LoadOnStartUp;
+	int m_CleanMailboxes;
+	int m_MinAuctions;
+	string m_Houses;
+	int m_AnnounceLoading;
+	int m_ExpirationMinutes;
+	int m_RandomizeExpiration;
+	string m_IncludeClasses;
+	int m_AllowQuestItems;
+	int m_MinItemLevel;
+	int m_MaxItemLevel;
+	int m_MinPlayerLevel;
+	int m_MaxPlayerLevel;
+	int m_MinItemQuality;
+	int m_MaxItemQuality;
+	int m_MaxItemCount;
+	int m_MaxStack;
+	int m_CustomPrices;
+	float m_BuyoutMultiplier;
+	float m_BidMultiplier;
+	string m_PlayerName;
+	uint32 m_PlayerGuid;
+
+public:
+	AHBotUpdaterThread();
+	~AHBotUpdaterThread();
+
+	bool run();
+	void terminate();
+
+	void load_threadsettings();
+
+	bool has_mail_expired(time_t now_time, time_t last_time);
+	bool has_update_expired(time_t now_time, time_t last_time);
+	bool has_playeritems_expired(time_t now_time, time_t last_time);
+
+	void update_auctionhouse();
+	bool add_item(Player * plr, AuctionHouse * ah, uint32 itemToAdd, uint32 auctionExpire);
+	bool preload_auctionhouse(AuctionHouse * ah);
+	bool load_auctionhouse(AuctionHouse * ah, uint32 itemsToAdd);
+	bool load_auctionhouse(Player * plr, AuctionHouse * ah, uint32 itemsToAdd);
+	void unload_auctionhouse(Player * plr, AuctionHouse * ah);
+	void startup_auctionhouse(uint32 ahid, uint32 itemThreshold);
+
+	void clean_mailboxes();
+	void clean_playeritems();
+	void clear_auctionhouses();
+};
+
+#endif
Index: src/ascent-world/AuctionHouse.cpp
===================================================================
--- src/ascent-world/AuctionHouse.cpp	(Revision 5060)
+++ src/ascent-world/AuctionHouse.cpp	(Arbeitskopie)
@@ -124,6 +124,7 @@
 	auctionedItems.insert( HM_NAMESPACE::hash_map<uint64, Item*>::value_type( auct->pItem->GetGUID(), auct->pItem ) );
 	itemLock.ReleaseWriteLock();
 
+	if((!auct->Owner == sAHBotMgr.m_PlayerGuid) || (sAHBotMgr.m_LogLevel >= 2))
 	Log.Debug("AuctionHouse", "%u: Add auction %u, expire@ %u.", dbc->id, auct->Id, auct->ExpiryTime);
 }
 
@@ -141,6 +142,7 @@
 void AuctionHouse::RemoveAuction(Auction * auct)
 {
 	Log.Debug("AuctionHouse", "%u: Removing auction %u, reason %u.", dbc->id, auct->Id, auct->DeletedReason);
+	sAHBotMgr.ModifyRemoveAuction(dbc, auct); // when owner is playerGuid, it was an automatically loaded item and can be manipulated in some cases
 
 	char subject[100];
 	char body[200];
@@ -152,6 +154,7 @@
 			snprintf(subject, 100, "%u:0:3", (unsigned int)auct->pItem->GetEntry());
 
 			// Auction expired, resend item, no money to owner.
+			if (auct->Owner != sAHBotMgr.m_PlayerGuid) // when owner is playerGuid, it was an automatically loaded item and can be ignored
 			sMailSystem.SendAutomatedMessage(AUCTION, dbc->id, auct->Owner, subject, "", 0, 0, auct->pItem->GetGUID(), 62);
 		}break;
 
@@ -182,6 +185,7 @@
 				snprintf(body, 200, "%X:%u:0:%u:%u", (unsigned int)auct->HighestBidder, (unsigned int)auct->HighestBid, (unsigned int)auct->DepositAmount, (unsigned int)auction_cut);
 
 			// send message away.
+			if (auct->Owner != sAHBotMgr.m_PlayerGuid) // when owner is playerGuid, it was an automatically loaded item and can be ignored
 			sMailSystem.SendAutomatedMessage(AUCTION, dbc->id, auct->Owner, subject, body, amount, 0, 0, 62);
 		}break;
 	case AUCTION_REMOVE_CANCELLED:
@@ -214,6 +218,11 @@
 	auctionLock.ReleaseWriteLock();
 	itemLock.ReleaseWriteLock();
 
+	// Let's try deleting here again since some seem to be slipping through
+	if((auct->Owner == sAHBotMgr.m_PlayerGuid) && (auct->DeletedReason != AUCTION_REMOVE_WON))
+		auct->pItem->DeleteFromDB();
+
+
 	// Destroy the item from memory (it still remains in the db)
 	delete auct->pItem;
 
@@ -371,7 +380,7 @@
 	// Find Item
 	AuctionHouse * ah = pCreature->auctionHouse;
 	Auction * auct = ah->GetAuction(auction_id);
-	if(auct == 0 || !auct->Owner || !_player || auct->Owner == _player->GetGUID())
+	if(auct == 0 || !_player || auct->Owner == _player->GetGUID()) // || !auct->Owner
 		return;
 
 	if(auct->HighestBid > price && price != auct->BuyoutPrice)
@@ -400,7 +409,8 @@
 
 		// send response packet
 		WorldPacket data(SMSG_AUCTION_COMMAND_RESULT, 12);
-		data << auct->Id << uint32(AUCTION_CANCEL) << uint32(0) << uint32(0);
+		//data << auct->Id << uint32(AUCTION_CANCEL) << uint32(0) << uint32(0);
+		data << auct->Id << uint32(AUCTION_BUYOUT) << uint32(0) << uint32(0);
 		SendPacket(&data);
 	}
 	else
Index: src/ascent-world/AuctionHouse.h
===================================================================
--- src/ascent-world/AuctionHouse.h	(Revision 5060)
+++ src/ascent-world/AuctionHouse.h	(Arbeitskopie)
@@ -81,6 +81,7 @@
 
 	ASCENT_INLINE uint32 GetID() { return dbc->id; }
 	void LoadAuctions();
+	void UnloadAHBotAuctions();
 
 	void UpdateAuctions();
 	void UpdateDeletionQueue();
@@ -94,6 +95,7 @@
 	void SendBidListPacket(Player * plr, WorldPacket * packet);
 	void SendAuctionNotificationPacket(Player * plr, Auction * auct);
 	void SendAuctionList(Player * plr, WorldPacket * packet);
+	uint32 CountSpecificItemId(uint32 itemid);
 
 private:
 	RWLock itemLock;
Index: src/ascent-world/Chat.cpp
===================================================================
--- src/ascent-world/Chat.cpp	(Revision 5060)
+++ src/ascent-world/Chat.cpp	(Arbeitskopie)
@@ -48,6 +48,8 @@
 		return _CheatCommandTable;
 	else if(!strcmp(name, "account"))
 		return _accountCommandTable;
+	else if(!strcmp(name, "ahbot"))
+		return _AHBotCommandTable;
 	else if(!strcmp(name, "pet"))
 		return _petCommandTable;
 	else if(!strcmp(name, "recall"))
@@ -184,6 +186,7 @@
 	free( _honorCommandTable );
 	free( _GuildCommandTable);
 	free( _questCommandTable );
+	free( _AHBotCommandTable );
 	//free( _charCommandTable );
 	free( _commandTable );
 }
@@ -391,6 +394,25 @@
 	};
 	dupe_command_table(accountCommandTable, _accountCommandTable);
 
+	static ChatCommand AHBotCommandTable[] =
+	{
+		{ "auto",		'1', &ChatHandler::HandleAHBotAutoCommand,		"Executes the automatic startup sequence",			NULL, 0, 0, 0},
+		{ "clear",		'1', &ChatHandler::HandleAHBotClearCommand,		"Clears all the auctions from all auction houses",	NULL, 0, 0, 0},
+		{ "config",		'1', &ChatHandler::HandleAHBotConfigCommand,	"Displays AHBot configuration information",			NULL, 0, 0, 0},
+		{ "count",		'1', &ChatHandler::HandleAHBotCountCommand,		"Counts the number of auctions",					NULL, 0, 0, 0},
+		{ "list",		'1', &ChatHandler::HandleAHBotListCommand,		"Lists the Auction Houses with their ids",			NULL, 0, 0, 0},
+		{ "loglevel",	'1', &ChatHandler::HandleAHBotLogLevelCommand,	"Change the AHBot log level",						NULL, 0, 0, 0},
+		{ "load",		'1', &ChatHandler::HandleAHBotLoadCommand,		"Loads the Auction House with x items",				NULL, 0, 0, 0},
+		{ "reload",		'1', &ChatHandler::HandleAHBotReloadCommand,	"Re-loads all auction houses from SQL",				NULL, 0, 0, 0},
+		{ "preload",	'1', &ChatHandler::HandleAHBotPreLoadCommand,	"Loads the Auction House from the AHBotItems table",	NULL, 0, 0, 0},
+		{ "refresh",	'1', &ChatHandler::HandleAHBotRefreshCommand,	"Loads the Auction House from the AHBotItems table",	NULL, 0, 0, 0},
+		{ "time",		'1', &ChatHandler::HandleAHBotTimeCommand,		"Display the current UNIXTIME used to calc expire",	NULL, 0, 0, 0},
+		{ "unload",		'1', &ChatHandler::HandleAHBotUnloadCommand,	"Unloads auto-loaded items from the Auction House",	NULL, 0, 0, 0},
+
+		{ NULL, 0, NULL, "", NULL, 0, 0, 0},
+	};
+	dupe_command_table(AHBotCommandTable, _AHBotCommandTable);
+
 	static ChatCommand honorCommandTable[] =
 	{
 		{ "addpoints",   'm', &ChatHandler::HandleAddHonorCommand,	  "Adds x amount of honor points/currency",NULL,0,0,0},
@@ -519,6 +541,7 @@
 		{ "npc"		 ,  'n', NULL,									 "",					NPCCommandTable, 0, 0, 0},
 		{ "cheat"	   ,  'm', NULL,									 "",				  CheatCommandTable, 0, 0, 0},
 		{ "account"	   ,  'a', NULL,									 "",				  accountCommandTable, 0, 0, 0},
+		{ "ahbot"	   ,  'a', NULL,									 "",				  AHBotCommandTable, 0, 0, 0},
 		{ "honor"	   ,  'm', NULL,									 "",				  honorCommandTable, 0, 0, 0},
 		{ "quest",		'q', NULL,									 "",				 questCommandTable, 0, 0, 0},
 		{ "pet",		   'm', NULL,									 "",					petCommandTable, 0, 0, 0},
Index: src/ascent-world/Chat.h
===================================================================
--- src/ascent-world/Chat.h	(Revision 5060)
+++ src/ascent-world/Chat.h	(Arbeitskopie)
@@ -148,6 +148,7 @@
 	ChatCommand * _BattlegroundCommandTable;
 	ChatCommand * _NPCCommandTable;
 	ChatCommand * _accountCommandTable;
+	ChatCommand * _AHBotCommandTable;
 	ChatCommand * _CheatCommandTable;
 	ChatCommand * _honorCommandTable;
 	ChatCommand * _questCommandTable;
@@ -517,6 +518,21 @@
 	bool HandleFixScaleCommand(const char * args, WorldSession * m_session);
 	bool HandleAddTrainerSpellCommand( const char * args, WorldSession * m_session );
 	bool HandleWSCommand( const char * args, WorldSession * m_session );
+
+	/* AHBot COMMANDS */
+	bool HandleAHBotAutoCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotClearCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotConfigCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotCountCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotListCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotLogLevelCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotLoadCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotReloadCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotPreLoadCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotTimeCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotUnloadCommand(const char* args, WorldSession *m_session);
+	bool HandleAHBotRefreshCommand(const char* args, WorldSession *m_session);
+
 };
 
 
Index: src/ascent-world/ConsoleCommands.cpp
===================================================================
--- src/ascent-world/ConsoleCommands.cpp	(Revision 5060)
+++ src/ascent-world/ConsoleCommands.cpp	(Arbeitskopie)
@@ -58,6 +58,25 @@
 	return true;
 }
 
+bool HandleAHBotCommand(BaseConsole * pConsole, int argc, const char * argv[])
+{
+	string outstr = "";
+
+	if(argc > 0)
+	{
+		for(int i = 1; i < argc; ++i)
+		{
+			outstr += argv[i];
+			if((i+1) != (argc))
+				outstr += " ";
+		}
+	}
+
+	sAHBotMgr.AHBotConsoleCommands(pConsole, argc, outstr);
+
+	return true;
+}
+
 bool HandleGMsCommand(BaseConsole * pConsole, int argc, const char * argv[])
 {
 	WorldPacket data;
Index: src/ascent-world/ConsoleCommands.h
===================================================================
--- src/ascent-world/ConsoleCommands.h	(Revision 5060)
+++ src/ascent-world/ConsoleCommands.h	(Arbeitskopie)
@@ -25,6 +25,7 @@
 bool HandleCancelCommand(BaseConsole * pConsole, int argc, const char * argv[]);
 bool HandleCreateAccountCommand(BaseConsole * pConsole, int argc, const char * argv[]);
 bool HandleInfoCommand(BaseConsole * pConsole, int argc, const char * argv[]);
+bool HandleAHBotCommand(BaseConsole * pConsole, int argc, const char * argv[]);
 bool HandleGMsCommand(BaseConsole * pConsole, int argc, const char * argv[]);
 bool HandleKickCommand(BaseConsole * pConsole, int argc, const char * argv[]);
 bool HandleMOTDCommand(BaseConsole * pConsole, int argc, const char * argv[]);
Index: src/ascent-world/ConsoleListener.cpp
===================================================================
--- src/ascent-world/ConsoleListener.cpp	(Revision 5060)
+++ src/ascent-world/ConsoleListener.cpp	(Arbeitskopie)
@@ -343,6 +343,7 @@
 		{ &HandleCancelCommand, "cancel", "none", "Cancels a pending shutdown." },
 		{ &HandleCreateAccountCommand, "createaccount", "<name> <pass> <email> <flags>", "Creates an account." },
 		{ &HandleInfoCommand, "info", "none", "Gives server runtime information." },
+		{ &HandleAHBotCommand, "ahbot", "<subcommand>", "Execute AHbot commands from the console." },
 		{ &HandleGMsCommand, "gms", "none", "Shows online GMs." },
 		{ &HandleKickCommand, "kick", "<plrname> <reason>", "Kicks player x for reason y." },
 		{ &HandleMOTDCommand, "getmotd", "none", "View the current MOTD" },
Index: src/ascent-world/Container.h
===================================================================
--- src/ascent-world/Container.h	(Revision 5060)
+++ src/ascent-world/Container.h	(Arbeitskopie)
@@ -28,6 +28,7 @@
 	~Container();
 
 	void Create( uint32 itemid, Player *owner );
+	void Create( uint32 itemid, Player *owner, ItemPrototype *proto );
 	void LoadFromDB( Field*fields);
 
 	bool AddItem(int8 slot, Item *item);
Index: src/ascent-world/Item.h
===================================================================
--- src/ascent-world/Item.h	(Revision 5060)
+++ src/ascent-world/Item.h	(Arbeitskopie)
@@ -121,6 +121,7 @@
 	virtual ~Item();
 
 	void Create( uint32 itemid, Player* owner );
+	void Create( uint32 itemid, Player* owner, ItemPrototype* proto );
 
 	ASCENT_INLINE ItemPrototype* GetProto() const { return m_itemProto; }
 	ASCENT_INLINE void SetProto( ItemPrototype* pr ) { m_itemProto = pr; }
Index: src/ascent-world/Makefile.am
===================================================================
--- src/ascent-world/Makefile.am	(Revision 5060)
+++ src/ascent-world/Makefile.am	(Arbeitskopie)
@@ -19,6 +19,10 @@
     ObjectStorage.h \
     AddonMgr.cpp \
     AddonMgr.h \
+    AHBot.cpp \
+    AHBot.h \
+    AHBotThread.cpp \
+    AHBotThread.h \
     AIInterface.cpp \
     AIInterface.h \
     AlteracValley.cpp \
Index: src/ascent-world/Master.cpp
===================================================================
--- src/ascent-world/Master.cpp	(Revision 5060)
+++ src/ascent-world/Master.cpp	(Arbeitskopie)
@@ -45,6 +45,7 @@
 SessionLogWriter* Anticheat_Log;
 SessionLogWriter* Player_Log;
 extern DayWatcherThread * dw;
+extern AHBotUpdaterThread * aht;
 
 void Master::_OnSignal(int s)
 {
@@ -517,6 +518,10 @@
 	dw->terminate();
 	dw = NULL;
 
+	Log.Notice("AHBotUpdaterThread", "Exiting...");
+	aht->terminate();
+	aht = NULL;
+
 #ifndef CLUSTERING
 	ls->Close();
 #endif
Index: src/ascent-world/ObjectMgr.h
===================================================================
--- src/ascent-world/ObjectMgr.h	(Revision 5060)
+++ src/ascent-world/ObjectMgr.h	(Arbeitskopie)
@@ -358,6 +358,7 @@
 	uint32 m_hiGuildId;
 	
 	Item * CreateItem(uint32 entry,Player * owner);
+	Item * CreateItem(uint32 entry,Player * owner,ItemPrototype * proto);
 	Item * LoadItem(uint64 guid);
 	Item * LoadExternalItem(uint64 guid);
   
Index: src/ascent-world/StdAfx.h
===================================================================
--- src/ascent-world/StdAfx.h	(Revision 5060)
+++ src/ascent-world/StdAfx.h	(Arbeitskopie)
@@ -75,6 +75,9 @@
 #include "UpdateMask.h"
 #include "Opcodes.h"
 
+#include "AHBot.h"
+#include "AHBotThread.h"
+
 #ifdef CLUSTERING
 	#include "../ascent-realmserver/WorkerOpcodes.h"
 #endif
Index: src/ascent-world/World.cpp
===================================================================
--- src/ascent-world/World.cpp	(Revision 5060)
+++ src/ascent-world/World.cpp	(Arbeitskopie)
@@ -22,6 +22,7 @@
 initialiseSingleton( World );
 
 DayWatcherThread* dw = NULL;
+AHBotUpdaterThread * aht = NULL;
 
 float World::m_movementCompressThreshold;
 float World::m_movementCompressThresholdCreatures;
@@ -485,6 +486,12 @@
 	new AuctionMgr;
 	sAuctionMgr.LoadAuctionHouses();
 
+	Log.Notice("World", "Starting Automatic Auction Loading System...");
+	new AHBot;
+	sAHBotMgr.LoadSettings();
+	aht = new AHBotUpdaterThread();
+	ThreadPool.ExecuteTask(aht);
+
 	m_queueUpdateTimer = mQueueUpdateInterval;
 	if(Config.MainConfig.GetBoolDefault("Startup", "BackgroundLootLoading", true))
 	{
Index: win/VC90/ascent-world.vcproj
===================================================================
--- win/VC90/ascent-world.vcproj	(Revision 5060)
+++ win/VC90/ascent-world.vcproj	(Arbeitskopie)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="9.00"
+	Version="9,00"
 	Name="ascent-world"
 	ProjectGUID="{1DC6C4DA-A028-41F3-877D-D5400C594F88}"
 	RootNamespace="game"
@@ -109,13 +109,14 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|x64"
-			OutputDirectory=".\..\..\bin\Debug_x64"
-			IntermediateDirectory=".\ascent-world___Win32_Debug_x64"
+			Name="Release|Win32"
+			OutputDirectory=".\..\..\bin\Release"
+			IntermediateDirectory=".\ascent-world___Win32_Release"
 			ConfigurationType="1"
 			UseOfMFC="0"
 			ATLMinimizesCRunTimeLibraryUsage="false"
 			CharacterSet="2"
+			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -131,26 +132,30 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
-				TargetEnvironment="3"
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
 				AdditionalOptions="/Zm250"
-				Optimization="0"
+				Optimization="4"
 				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				OmitFramePointers="true"
+				WholeProgramOptimization="true"
 				AdditionalIncludeDirectories="..\..\src\ascent-shared; ..\..\src\ascent-shared\g3dlite; ..\..\src\ascent-shared\vmap"
-				PreprocessorDefinitions="WIN32,_DEBUG,_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;X64"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="1"
+				PreprocessorDefinitions="_HAS_ITERATOR_DEBUGGING=0;WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS"
+				StringPooling="true"
+				MinimalRebuild="false"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
 				EnableFunctionLevelLinking="false"
-				RuntimeTypeInfo="false"
+				EnableEnhancedInstructionSet="0"
+				FloatingPointModel="2"
 				UsePrecompiledHeader="2"
 				PrecompiledHeaderFile="$(IntDir)/game.pch"
 				AssemblerListingLocation="$(IntDir)/"
 				ObjectFile="$(IntDir)/"
 				ProgramDataBaseFileName="$(IntDir)/"
-				BrowseInformation="0"
 				WarningLevel="3"
 				SuppressStartupBanner="true"
 				Detect64BitPortabilityProblems="false"
@@ -162,7 +167,7 @@
 			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
+				PreprocessorDefinitions="NDEBUG"
 				Culture="1033"
 			/>
 			<Tool
@@ -171,7 +176,7 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalDependencies="ws2_32.lib libmysql.lib libeay32.lib dbghelp.lib zlib.lib pcre.lib"
-				AdditionalLibraryDirectories="..\..\extras\collision\collision_dll\x64\Debug"
+				AdditionalLibraryDirectories="..\..\extras\collision\collision_dll\Release"
 				GenerateDebugInformation="true"
 				RandomizedBaseAddress="1"
 				DataExecutionPrevention="0"
@@ -200,14 +205,13 @@
 			/>
 		</Configuration>
 		<Configuration
-			Name="Release|Win32"
-			OutputDirectory=".\..\..\bin\Release"
-			IntermediateDirectory=".\ascent-world___Win32_Release"
+			Name="Debug|x64"
+			OutputDirectory=".\..\..\bin\Debug_x64"
+			IntermediateDirectory=".\ascent-world___Win32_Debug_x64"
 			ConfigurationType="1"
 			UseOfMFC="0"
 			ATLMinimizesCRunTimeLibraryUsage="false"
 			CharacterSet="2"
-			WholeProgramOptimization="1"
 			>
 			<Tool
 				Name="VCPreBuildEventTool"
@@ -223,30 +227,26 @@
 			/>
 			<Tool
 				Name="VCMIDLTool"
+				TargetEnvironment="3"
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
 				AdditionalOptions="/Zm250"
-				Optimization="4"
+				Optimization="0"
 				InlineFunctionExpansion="2"
-				EnableIntrinsicFunctions="true"
-				FavorSizeOrSpeed="1"
-				OmitFramePointers="true"
-				WholeProgramOptimization="true"
 				AdditionalIncludeDirectories="..\..\src\ascent-shared; ..\..\src\ascent-shared\g3dlite; ..\..\src\ascent-shared\vmap"
-				PreprocessorDefinitions="_HAS_ITERATOR_DEBUGGING=0;WIN32;NDEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS"
-				StringPooling="true"
-				MinimalRebuild="false"
-				RuntimeLibrary="2"
-				BufferSecurityCheck="false"
+				PreprocessorDefinitions="WIN32,_DEBUG,_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;X64"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
 				EnableFunctionLevelLinking="false"
-				EnableEnhancedInstructionSet="0"
-				FloatingPointModel="2"
+				RuntimeTypeInfo="false"
 				UsePrecompiledHeader="2"
 				PrecompiledHeaderFile="$(IntDir)/game.pch"
 				AssemblerListingLocation="$(IntDir)/"
 				ObjectFile="$(IntDir)/"
 				ProgramDataBaseFileName="$(IntDir)/"
+				BrowseInformation="0"
 				WarningLevel="3"
 				SuppressStartupBanner="true"
 				Detect64BitPortabilityProblems="false"
@@ -258,7 +258,7 @@
 			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
+				PreprocessorDefinitions="_DEBUG"
 				Culture="1033"
 			/>
 			<Tool
@@ -267,7 +267,7 @@
 			<Tool
 				Name="VCLinkerTool"
 				AdditionalDependencies="ws2_32.lib libmysql.lib libeay32.lib dbghelp.lib zlib.lib pcre.lib"
-				AdditionalLibraryDirectories="..\..\extras\collision\collision_dll\Release"
+				AdditionalLibraryDirectories="..\..\extras\collision\collision_dll\x64\Debug"
 				GenerateDebugInformation="true"
 				RandomizedBaseAddress="1"
 				DataExecutionPrevention="0"
@@ -408,7 +408,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Debug|x64"
+					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -416,7 +416,7 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
-					Name="Release|Win32"
+					Name="Debug|x64"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
@@ -482,6 +482,22 @@
 			>
 		</File>
 		<File
+			RelativePath="..\..\src\ascent-world\AHBot.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\ascent-world\AHBot.h"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\ascent-world\AHBotThread.cpp"
+			>
+		</File>
+		<File
+			RelativePath="..\..\src\ascent-world\AHBotThread.h"
+			>
+		</File>
+		<File
 			RelativePath="..\..\src\ascent-world\AIInterface.cpp"
 			>
 		</File>
@@ -1085,7 +1101,7 @@
 				/>
 			</FileConfiguration>
 			<FileConfiguration
-				Name="Debug|x64"
+				Name="Release|Win32"
 				>
 				<Tool
 					Name="VCCLCompilerTool"
@@ -1093,7 +1109,7 @@
 				/>
 			</FileConfiguration>
 			<FileConfiguration
-				Name="Release|Win32"
+				Name="Debug|x64"
 				>
 				<Tool
 					Name="VCCLCompilerTool"
@@ -1258,11 +1274,11 @@
 			>
 		</File>
 		<File
-			RelativePath="..\..\src\ascent-world\WorldState.h"
+			RelativePath="..\..\src\ascent-world\WorldState.cpp"
 			>
 		</File>
 		<File
-			RelativePath="..\..\src\ascent-world\WorldState.cpp"
+			RelativePath="..\..\src\ascent-world\WorldState.h"
 			>
 		</File>
 	</Files>
